// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 29.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gtfs-realtime.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:transit_realtime.FeedMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeedMessage {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.FeedMessage.header)
    pub header: ::protobuf::MessageField<FeedHeader>,
    // @@protoc_insertion_point(field:transit_realtime.FeedMessage.entity)
    pub entity: ::std::vec::Vec<FeedEntity>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.FeedMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeedMessage {
    fn default() -> &'a FeedMessage {
        <FeedMessage as ::protobuf::Message>::default_instance()
    }
}

impl FeedMessage {
    pub fn new() -> FeedMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FeedHeader>(
            "header",
            |m: &FeedMessage| { &m.header },
            |m: &mut FeedMessage| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entity",
            |m: &FeedMessage| { &m.entity },
            |m: &mut FeedMessage| { &mut m.entity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeedMessage>(
            "FeedMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeedMessage {
    const NAME: &'static str = "FeedMessage";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.entity.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.entity {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.entity {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeedMessage {
        FeedMessage::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.entity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeedMessage {
        static instance: FeedMessage = FeedMessage {
            header: ::protobuf::MessageField::none(),
            entity: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeedMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeedMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:transit_realtime.FeedHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeedHeader {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.FeedHeader.gtfs_realtime_version)
    pub gtfs_realtime_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.FeedHeader.incrementality)
    pub incrementality: ::std::option::Option<::protobuf::EnumOrUnknown<feed_header::Incrementality>>,
    // @@protoc_insertion_point(field:transit_realtime.FeedHeader.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:transit_realtime.FeedHeader.feed_version)
    pub feed_version: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.FeedHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeedHeader {
    fn default() -> &'a FeedHeader {
        <FeedHeader as ::protobuf::Message>::default_instance()
    }
}

impl FeedHeader {
    pub fn new() -> FeedHeader {
        ::std::default::Default::default()
    }

    // required string gtfs_realtime_version = 1;

    pub fn gtfs_realtime_version(&self) -> &str {
        match self.gtfs_realtime_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gtfs_realtime_version(&mut self) {
        self.gtfs_realtime_version = ::std::option::Option::None;
    }

    pub fn has_gtfs_realtime_version(&self) -> bool {
        self.gtfs_realtime_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gtfs_realtime_version(&mut self, v: ::std::string::String) {
        self.gtfs_realtime_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gtfs_realtime_version(&mut self) -> &mut ::std::string::String {
        if self.gtfs_realtime_version.is_none() {
            self.gtfs_realtime_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gtfs_realtime_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_gtfs_realtime_version(&mut self) -> ::std::string::String {
        self.gtfs_realtime_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2;

    pub fn incrementality(&self) -> feed_header::Incrementality {
        match self.incrementality {
            Some(e) => e.enum_value_or(feed_header::Incrementality::FULL_DATASET),
            None => feed_header::Incrementality::FULL_DATASET,
        }
    }

    pub fn clear_incrementality(&mut self) {
        self.incrementality = ::std::option::Option::None;
    }

    pub fn has_incrementality(&self) -> bool {
        self.incrementality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incrementality(&mut self, v: feed_header::Incrementality) {
        self.incrementality = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 timestamp = 3;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string feed_version = 4;

    pub fn feed_version(&self) -> &str {
        match self.feed_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_feed_version(&mut self) {
        self.feed_version = ::std::option::Option::None;
    }

    pub fn has_feed_version(&self) -> bool {
        self.feed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed_version(&mut self, v: ::std::string::String) {
        self.feed_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed_version(&mut self) -> &mut ::std::string::String {
        if self.feed_version.is_none() {
            self.feed_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.feed_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_feed_version(&mut self) -> ::std::string::String {
        self.feed_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gtfs_realtime_version",
            |m: &FeedHeader| { &m.gtfs_realtime_version },
            |m: &mut FeedHeader| { &mut m.gtfs_realtime_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "incrementality",
            |m: &FeedHeader| { &m.incrementality },
            |m: &mut FeedHeader| { &mut m.incrementality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &FeedHeader| { &m.timestamp },
            |m: &mut FeedHeader| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "feed_version",
            |m: &FeedHeader| { &m.feed_version },
            |m: &mut FeedHeader| { &mut m.feed_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeedHeader>(
            "FeedHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeedHeader {
    const NAME: &'static str = "FeedHeader";

    fn is_initialized(&self) -> bool {
        if self.gtfs_realtime_version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gtfs_realtime_version = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.incrementality = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.feed_version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gtfs_realtime_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.incrementality {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.feed_version.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gtfs_realtime_version.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.incrementality {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.feed_version.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeedHeader {
        FeedHeader::new()
    }

    fn clear(&mut self) {
        self.gtfs_realtime_version = ::std::option::Option::None;
        self.incrementality = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.feed_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeedHeader {
        static instance: FeedHeader = FeedHeader {
            gtfs_realtime_version: ::std::option::Option::None,
            incrementality: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            feed_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeedHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeedHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeedHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FeedHeader`
pub mod feed_header {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.FeedHeader.Incrementality)
    pub enum Incrementality {
        // @@protoc_insertion_point(enum_value:transit_realtime.FeedHeader.Incrementality.FULL_DATASET)
        FULL_DATASET = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.FeedHeader.Incrementality.DIFFERENTIAL)
        DIFFERENTIAL = 1,
    }

    impl ::protobuf::Enum for Incrementality {
        const NAME: &'static str = "Incrementality";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Incrementality> {
            match value {
                0 => ::std::option::Option::Some(Incrementality::FULL_DATASET),
                1 => ::std::option::Option::Some(Incrementality::DIFFERENTIAL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Incrementality> {
            match str {
                "FULL_DATASET" => ::std::option::Option::Some(Incrementality::FULL_DATASET),
                "DIFFERENTIAL" => ::std::option::Option::Some(Incrementality::DIFFERENTIAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Incrementality] = &[
            Incrementality::FULL_DATASET,
            Incrementality::DIFFERENTIAL,
        ];
    }

    impl ::protobuf::EnumFull for Incrementality {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FeedHeader.Incrementality").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Incrementality {
        fn default() -> Self {
            Incrementality::FULL_DATASET
        }
    }

    impl Incrementality {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Incrementality>("FeedHeader.Incrementality")
        }
    }
}

// @@protoc_insertion_point(message:transit_realtime.FeedEntity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeedEntity {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.is_deleted)
    pub is_deleted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.trip_update)
    pub trip_update: ::protobuf::MessageField<TripUpdate>,
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.vehicle)
    pub vehicle: ::protobuf::MessageField<VehiclePosition>,
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.alert)
    pub alert: ::protobuf::MessageField<Alert>,
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.shape)
    pub shape: ::protobuf::MessageField<Shape>,
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.stop)
    pub stop: ::protobuf::MessageField<Stop>,
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.trip_modifications)
    pub trip_modifications: ::protobuf::MessageField<TripModifications>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.FeedEntity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeedEntity {
    fn default() -> &'a FeedEntity {
        <FeedEntity as ::protobuf::Message>::default_instance()
    }
}

impl FeedEntity {
    pub fn new() -> FeedEntity {
        ::std::default::Default::default()
    }

    // required string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_deleted = 2;

    pub fn is_deleted(&self) -> bool {
        self.is_deleted.unwrap_or(false)
    }

    pub fn clear_is_deleted(&mut self) {
        self.is_deleted = ::std::option::Option::None;
    }

    pub fn has_is_deleted(&self) -> bool {
        self.is_deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_deleted(&mut self, v: bool) {
        self.is_deleted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &FeedEntity| { &m.id },
            |m: &mut FeedEntity| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_deleted",
            |m: &FeedEntity| { &m.is_deleted },
            |m: &mut FeedEntity| { &mut m.is_deleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TripUpdate>(
            "trip_update",
            |m: &FeedEntity| { &m.trip_update },
            |m: &mut FeedEntity| { &mut m.trip_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VehiclePosition>(
            "vehicle",
            |m: &FeedEntity| { &m.vehicle },
            |m: &mut FeedEntity| { &mut m.vehicle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Alert>(
            "alert",
            |m: &FeedEntity| { &m.alert },
            |m: &mut FeedEntity| { &mut m.alert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Shape>(
            "shape",
            |m: &FeedEntity| { &m.shape },
            |m: &mut FeedEntity| { &mut m.shape },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Stop>(
            "stop",
            |m: &FeedEntity| { &m.stop },
            |m: &mut FeedEntity| { &mut m.stop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TripModifications>(
            "trip_modifications",
            |m: &FeedEntity| { &m.trip_modifications },
            |m: &mut FeedEntity| { &mut m.trip_modifications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeedEntity>(
            "FeedEntity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeedEntity {
    const NAME: &'static str = "FeedEntity";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.trip_update {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vehicle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alert {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trip_modifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.is_deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip_update)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vehicle)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.alert)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shape)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stop)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip_modifications)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.is_deleted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trip_update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vehicle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.alert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trip_modifications.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.is_deleted {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.trip_update.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.vehicle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.alert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.shape.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.stop.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.trip_modifications.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeedEntity {
        FeedEntity::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.is_deleted = ::std::option::Option::None;
        self.trip_update.clear();
        self.vehicle.clear();
        self.alert.clear();
        self.shape.clear();
        self.stop.clear();
        self.trip_modifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeedEntity {
        static instance: FeedEntity = FeedEntity {
            id: ::std::option::Option::None,
            is_deleted: ::std::option::Option::None,
            trip_update: ::protobuf::MessageField::none(),
            vehicle: ::protobuf::MessageField::none(),
            alert: ::protobuf::MessageField::none(),
            shape: ::protobuf::MessageField::none(),
            stop: ::protobuf::MessageField::none(),
            trip_modifications: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeedEntity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeedEntity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeedEntity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedEntity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:transit_realtime.TripUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TripUpdate {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.trip)
    pub trip: ::protobuf::MessageField<TripDescriptor>,
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.vehicle)
    pub vehicle: ::protobuf::MessageField<VehicleDescriptor>,
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.stop_time_update)
    pub stop_time_update: ::std::vec::Vec<trip_update::StopTimeUpdate>,
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.delay)
    pub delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.trip_properties)
    pub trip_properties: ::protobuf::MessageField<trip_update::TripProperties>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TripUpdate {
    fn default() -> &'a TripUpdate {
        <TripUpdate as ::protobuf::Message>::default_instance()
    }
}

impl TripUpdate {
    pub fn new() -> TripUpdate {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 4;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 delay = 5;

    pub fn delay(&self) -> i32 {
        self.delay.unwrap_or(0)
    }

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: i32) {
        self.delay = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TripDescriptor>(
            "trip",
            |m: &TripUpdate| { &m.trip },
            |m: &mut TripUpdate| { &mut m.trip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VehicleDescriptor>(
            "vehicle",
            |m: &TripUpdate| { &m.vehicle },
            |m: &mut TripUpdate| { &mut m.vehicle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stop_time_update",
            |m: &TripUpdate| { &m.stop_time_update },
            |m: &mut TripUpdate| { &mut m.stop_time_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &TripUpdate| { &m.timestamp },
            |m: &mut TripUpdate| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay",
            |m: &TripUpdate| { &m.delay },
            |m: &mut TripUpdate| { &mut m.delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, trip_update::TripProperties>(
            "trip_properties",
            |m: &TripUpdate| { &m.trip_properties },
            |m: &mut TripUpdate| { &mut m.trip_properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TripUpdate>(
            "TripUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TripUpdate {
    const NAME: &'static str = "TripUpdate";

    fn is_initialized(&self) -> bool {
        if self.trip.is_none() {
            return false;
        }
        for v in &self.trip {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vehicle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stop_time_update {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trip_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vehicle)?;
                },
                18 => {
                    self.stop_time_update.push(is.read_message()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.delay = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip_properties)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vehicle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stop_time_update {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.delay {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.trip_properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vehicle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.stop_time_update {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.timestamp {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.delay {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.trip_properties.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TripUpdate {
        TripUpdate::new()
    }

    fn clear(&mut self) {
        self.trip.clear();
        self.vehicle.clear();
        self.stop_time_update.clear();
        self.timestamp = ::std::option::Option::None;
        self.delay = ::std::option::Option::None;
        self.trip_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TripUpdate {
        static instance: TripUpdate = TripUpdate {
            trip: ::protobuf::MessageField::none(),
            vehicle: ::protobuf::MessageField::none(),
            stop_time_update: ::std::vec::Vec::new(),
            timestamp: ::std::option::Option::None,
            delay: ::std::option::Option::None,
            trip_properties: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TripUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TripUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TripUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TripUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TripUpdate`
pub mod trip_update {
    // @@protoc_insertion_point(message:transit_realtime.TripUpdate.StopTimeEvent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StopTimeEvent {
        // message fields
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeEvent.delay)
        pub delay: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeEvent.time)
        pub time: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
        pub uncertainty: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.StopTimeEvent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StopTimeEvent {
        fn default() -> &'a StopTimeEvent {
            <StopTimeEvent as ::protobuf::Message>::default_instance()
        }
    }

    impl StopTimeEvent {
        pub fn new() -> StopTimeEvent {
            ::std::default::Default::default()
        }

        // optional int32 delay = 1;

        pub fn delay(&self) -> i32 {
            self.delay.unwrap_or(0)
        }

        pub fn clear_delay(&mut self) {
            self.delay = ::std::option::Option::None;
        }

        pub fn has_delay(&self) -> bool {
            self.delay.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delay(&mut self, v: i32) {
            self.delay = ::std::option::Option::Some(v);
        }

        // optional int64 time = 2;

        pub fn time(&self) -> i64 {
            self.time.unwrap_or(0)
        }

        pub fn clear_time(&mut self) {
            self.time = ::std::option::Option::None;
        }

        pub fn has_time(&self) -> bool {
            self.time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time(&mut self, v: i64) {
            self.time = ::std::option::Option::Some(v);
        }

        // optional int32 uncertainty = 3;

        pub fn uncertainty(&self) -> i32 {
            self.uncertainty.unwrap_or(0)
        }

        pub fn clear_uncertainty(&mut self) {
            self.uncertainty = ::std::option::Option::None;
        }

        pub fn has_uncertainty(&self) -> bool {
            self.uncertainty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_uncertainty(&mut self, v: i32) {
            self.uncertainty = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "delay",
                |m: &StopTimeEvent| { &m.delay },
                |m: &mut StopTimeEvent| { &mut m.delay },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time",
                |m: &StopTimeEvent| { &m.time },
                |m: &mut StopTimeEvent| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "uncertainty",
                |m: &StopTimeEvent| { &m.uncertainty },
                |m: &mut StopTimeEvent| { &mut m.uncertainty },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopTimeEvent>(
                "TripUpdate.StopTimeEvent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StopTimeEvent {
        const NAME: &'static str = "StopTimeEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.delay = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.time = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.uncertainty = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.delay {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.time {
                my_size += ::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.uncertainty {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.delay {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.time {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.uncertainty {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StopTimeEvent {
            StopTimeEvent::new()
        }

        fn clear(&mut self) {
            self.delay = ::std::option::Option::None;
            self.time = ::std::option::Option::None;
            self.uncertainty = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StopTimeEvent {
            static instance: StopTimeEvent = StopTimeEvent {
                delay: ::std::option::Option::None,
                time: ::std::option::Option::None,
                uncertainty: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StopTimeEvent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TripUpdate.StopTimeEvent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StopTimeEvent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StopTimeEvent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:transit_realtime.TripUpdate.StopTimeUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StopTimeUpdate {
        // message fields
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
        pub stop_sequence: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
        pub stop_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
        pub arrival: ::protobuf::MessageField<StopTimeEvent>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.departure)
        pub departure: ::protobuf::MessageField<StopTimeEvent>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.departure_occupancy_status)
        pub departure_occupancy_status: ::std::option::Option<::protobuf::EnumOrUnknown<super::vehicle_position::OccupancyStatus>>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
        pub schedule_relationship: ::std::option::Option<::protobuf::EnumOrUnknown<stop_time_update::ScheduleRelationship>>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
        pub stop_time_properties: ::protobuf::MessageField<stop_time_update::StopTimeProperties>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.StopTimeUpdate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StopTimeUpdate {
        fn default() -> &'a StopTimeUpdate {
            <StopTimeUpdate as ::protobuf::Message>::default_instance()
        }
    }

    impl StopTimeUpdate {
        pub fn new() -> StopTimeUpdate {
            ::std::default::Default::default()
        }

        // optional uint32 stop_sequence = 1;

        pub fn stop_sequence(&self) -> u32 {
            self.stop_sequence.unwrap_or(0)
        }

        pub fn clear_stop_sequence(&mut self) {
            self.stop_sequence = ::std::option::Option::None;
        }

        pub fn has_stop_sequence(&self) -> bool {
            self.stop_sequence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stop_sequence(&mut self, v: u32) {
            self.stop_sequence = ::std::option::Option::Some(v);
        }

        // optional string stop_id = 4;

        pub fn stop_id(&self) -> &str {
            match self.stop_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_stop_id(&mut self) {
            self.stop_id = ::std::option::Option::None;
        }

        pub fn has_stop_id(&self) -> bool {
            self.stop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stop_id(&mut self, v: ::std::string::String) {
            self.stop_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_stop_id(&mut self) -> &mut ::std::string::String {
            if self.stop_id.is_none() {
                self.stop_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.stop_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_stop_id(&mut self) -> ::std::string::String {
            self.stop_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;

        pub fn departure_occupancy_status(&self) -> super::vehicle_position::OccupancyStatus {
            match self.departure_occupancy_status {
                Some(e) => e.enum_value_or(super::vehicle_position::OccupancyStatus::EMPTY),
                None => super::vehicle_position::OccupancyStatus::EMPTY,
            }
        }

        pub fn clear_departure_occupancy_status(&mut self) {
            self.departure_occupancy_status = ::std::option::Option::None;
        }

        pub fn has_departure_occupancy_status(&self) -> bool {
            self.departure_occupancy_status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_departure_occupancy_status(&mut self, v: super::vehicle_position::OccupancyStatus) {
            self.departure_occupancy_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5;

        pub fn schedule_relationship(&self) -> stop_time_update::ScheduleRelationship {
            match self.schedule_relationship {
                Some(e) => e.enum_value_or(stop_time_update::ScheduleRelationship::SCHEDULED),
                None => stop_time_update::ScheduleRelationship::SCHEDULED,
            }
        }

        pub fn clear_schedule_relationship(&mut self) {
            self.schedule_relationship = ::std::option::Option::None;
        }

        pub fn has_schedule_relationship(&self) -> bool {
            self.schedule_relationship.is_some()
        }

        // Param is passed by value, moved
        pub fn set_schedule_relationship(&mut self, v: stop_time_update::ScheduleRelationship) {
            self.schedule_relationship = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stop_sequence",
                |m: &StopTimeUpdate| { &m.stop_sequence },
                |m: &mut StopTimeUpdate| { &mut m.stop_sequence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stop_id",
                |m: &StopTimeUpdate| { &m.stop_id },
                |m: &mut StopTimeUpdate| { &mut m.stop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StopTimeEvent>(
                "arrival",
                |m: &StopTimeUpdate| { &m.arrival },
                |m: &mut StopTimeUpdate| { &mut m.arrival },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StopTimeEvent>(
                "departure",
                |m: &StopTimeUpdate| { &m.departure },
                |m: &mut StopTimeUpdate| { &mut m.departure },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "departure_occupancy_status",
                |m: &StopTimeUpdate| { &m.departure_occupancy_status },
                |m: &mut StopTimeUpdate| { &mut m.departure_occupancy_status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "schedule_relationship",
                |m: &StopTimeUpdate| { &m.schedule_relationship },
                |m: &mut StopTimeUpdate| { &mut m.schedule_relationship },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stop_time_update::StopTimeProperties>(
                "stop_time_properties",
                |m: &StopTimeUpdate| { &m.stop_time_properties },
                |m: &mut StopTimeUpdate| { &mut m.stop_time_properties },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopTimeUpdate>(
                "TripUpdate.StopTimeUpdate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StopTimeUpdate {
        const NAME: &'static str = "StopTimeUpdate";

        fn is_initialized(&self) -> bool {
            for v in &self.arrival {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.departure {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.stop_time_properties {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stop_sequence = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.stop_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.arrival)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.departure)?;
                    },
                    56 => {
                        self.departure_occupancy_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    40 => {
                        self.schedule_relationship = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stop_time_properties)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stop_sequence {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stop_id.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.arrival.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.departure.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.departure_occupancy_status {
                my_size += ::protobuf::rt::int32_size(7, v.value());
            }
            if let Some(v) = self.schedule_relationship {
                my_size += ::protobuf::rt::int32_size(5, v.value());
            }
            if let Some(v) = self.stop_time_properties.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stop_sequence {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stop_id.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.arrival.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.departure.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.departure_occupancy_status {
                os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.schedule_relationship {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.stop_time_properties.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StopTimeUpdate {
            StopTimeUpdate::new()
        }

        fn clear(&mut self) {
            self.stop_sequence = ::std::option::Option::None;
            self.stop_id = ::std::option::Option::None;
            self.arrival.clear();
            self.departure.clear();
            self.departure_occupancy_status = ::std::option::Option::None;
            self.schedule_relationship = ::std::option::Option::None;
            self.stop_time_properties.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StopTimeUpdate {
            static instance: StopTimeUpdate = StopTimeUpdate {
                stop_sequence: ::std::option::Option::None,
                stop_id: ::std::option::Option::None,
                arrival: ::protobuf::MessageField::none(),
                departure: ::protobuf::MessageField::none(),
                departure_occupancy_status: ::std::option::Option::None,
                schedule_relationship: ::std::option::Option::None,
                stop_time_properties: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StopTimeUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TripUpdate.StopTimeUpdate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StopTimeUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StopTimeUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `StopTimeUpdate`
    pub mod stop_time_update {
        // @@protoc_insertion_point(message:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct StopTimeProperties {
            // message fields
            // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
            pub assigned_stop_id: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a StopTimeProperties {
            fn default() -> &'a StopTimeProperties {
                <StopTimeProperties as ::protobuf::Message>::default_instance()
            }
        }

        impl StopTimeProperties {
            pub fn new() -> StopTimeProperties {
                ::std::default::Default::default()
            }

            // optional string assigned_stop_id = 1;

            pub fn assigned_stop_id(&self) -> &str {
                match self.assigned_stop_id.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_assigned_stop_id(&mut self) {
                self.assigned_stop_id = ::std::option::Option::None;
            }

            pub fn has_assigned_stop_id(&self) -> bool {
                self.assigned_stop_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_assigned_stop_id(&mut self, v: ::std::string::String) {
                self.assigned_stop_id = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_assigned_stop_id(&mut self) -> &mut ::std::string::String {
                if self.assigned_stop_id.is_none() {
                    self.assigned_stop_id = ::std::option::Option::Some(::std::string::String::new());
                }
                self.assigned_stop_id.as_mut().unwrap()
            }

            // Take field
            pub fn take_assigned_stop_id(&mut self) -> ::std::string::String {
                self.assigned_stop_id.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "assigned_stop_id",
                    |m: &StopTimeProperties| { &m.assigned_stop_id },
                    |m: &mut StopTimeProperties| { &mut m.assigned_stop_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopTimeProperties>(
                    "TripUpdate.StopTimeUpdate.StopTimeProperties",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for StopTimeProperties {
            const NAME: &'static str = "StopTimeProperties";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.assigned_stop_id = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.assigned_stop_id.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.assigned_stop_id.as_ref() {
                    os.write_string(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> StopTimeProperties {
                StopTimeProperties::new()
            }

            fn clear(&mut self) {
                self.assigned_stop_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static StopTimeProperties {
                static instance: StopTimeProperties = StopTimeProperties {
                    assigned_stop_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for StopTimeProperties {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("TripUpdate.StopTimeUpdate.StopTimeProperties").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for StopTimeProperties {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for StopTimeProperties {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship)
        pub enum ScheduleRelationship {
            // @@protoc_insertion_point(enum_value:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SCHEDULED)
            SCHEDULED = 0,
            // @@protoc_insertion_point(enum_value:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED)
            SKIPPED = 1,
            // @@protoc_insertion_point(enum_value:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.NO_DATA)
            NO_DATA = 2,
            // @@protoc_insertion_point(enum_value:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.UNSCHEDULED)
            UNSCHEDULED = 3,
        }

        impl ::protobuf::Enum for ScheduleRelationship {
            const NAME: &'static str = "ScheduleRelationship";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ScheduleRelationship> {
                match value {
                    0 => ::std::option::Option::Some(ScheduleRelationship::SCHEDULED),
                    1 => ::std::option::Option::Some(ScheduleRelationship::SKIPPED),
                    2 => ::std::option::Option::Some(ScheduleRelationship::NO_DATA),
                    3 => ::std::option::Option::Some(ScheduleRelationship::UNSCHEDULED),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<ScheduleRelationship> {
                match str {
                    "SCHEDULED" => ::std::option::Option::Some(ScheduleRelationship::SCHEDULED),
                    "SKIPPED" => ::std::option::Option::Some(ScheduleRelationship::SKIPPED),
                    "NO_DATA" => ::std::option::Option::Some(ScheduleRelationship::NO_DATA),
                    "UNSCHEDULED" => ::std::option::Option::Some(ScheduleRelationship::UNSCHEDULED),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ScheduleRelationship] = &[
                ScheduleRelationship::SCHEDULED,
                ScheduleRelationship::SKIPPED,
                ScheduleRelationship::NO_DATA,
                ScheduleRelationship::UNSCHEDULED,
            ];
        }

        impl ::protobuf::EnumFull for ScheduleRelationship {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("TripUpdate.StopTimeUpdate.ScheduleRelationship").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for ScheduleRelationship {
            fn default() -> Self {
                ScheduleRelationship::SCHEDULED
            }
        }

        impl ScheduleRelationship {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ScheduleRelationship>("TripUpdate.StopTimeUpdate.ScheduleRelationship")
            }
        }
    }

    // @@protoc_insertion_point(message:transit_realtime.TripUpdate.TripProperties)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TripProperties {
        // message fields
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.TripProperties.trip_id)
        pub trip_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.TripProperties.start_date)
        pub start_date: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.TripProperties.start_time)
        pub start_time: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.TripProperties.shape_id)
        pub shape_id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.TripProperties.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TripProperties {
        fn default() -> &'a TripProperties {
            <TripProperties as ::protobuf::Message>::default_instance()
        }
    }

    impl TripProperties {
        pub fn new() -> TripProperties {
            ::std::default::Default::default()
        }

        // optional string trip_id = 1;

        pub fn trip_id(&self) -> &str {
            match self.trip_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_trip_id(&mut self) {
            self.trip_id = ::std::option::Option::None;
        }

        pub fn has_trip_id(&self) -> bool {
            self.trip_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trip_id(&mut self, v: ::std::string::String) {
            self.trip_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_trip_id(&mut self) -> &mut ::std::string::String {
            if self.trip_id.is_none() {
                self.trip_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.trip_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_trip_id(&mut self) -> ::std::string::String {
            self.trip_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string start_date = 2;

        pub fn start_date(&self) -> &str {
            match self.start_date.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_start_date(&mut self) {
            self.start_date = ::std::option::Option::None;
        }

        pub fn has_start_date(&self) -> bool {
            self.start_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_date(&mut self, v: ::std::string::String) {
            self.start_date = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_start_date(&mut self) -> &mut ::std::string::String {
            if self.start_date.is_none() {
                self.start_date = ::std::option::Option::Some(::std::string::String::new());
            }
            self.start_date.as_mut().unwrap()
        }

        // Take field
        pub fn take_start_date(&mut self) -> ::std::string::String {
            self.start_date.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string start_time = 3;

        pub fn start_time(&self) -> &str {
            match self.start_time.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: ::std::string::String) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_start_time(&mut self) -> &mut ::std::string::String {
            if self.start_time.is_none() {
                self.start_time = ::std::option::Option::Some(::std::string::String::new());
            }
            self.start_time.as_mut().unwrap()
        }

        // Take field
        pub fn take_start_time(&mut self) -> ::std::string::String {
            self.start_time.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string shape_id = 4;

        pub fn shape_id(&self) -> &str {
            match self.shape_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_shape_id(&mut self) {
            self.shape_id = ::std::option::Option::None;
        }

        pub fn has_shape_id(&self) -> bool {
            self.shape_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_shape_id(&mut self, v: ::std::string::String) {
            self.shape_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_shape_id(&mut self) -> &mut ::std::string::String {
            if self.shape_id.is_none() {
                self.shape_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.shape_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_shape_id(&mut self) -> ::std::string::String {
            self.shape_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "trip_id",
                |m: &TripProperties| { &m.trip_id },
                |m: &mut TripProperties| { &mut m.trip_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_date",
                |m: &TripProperties| { &m.start_date },
                |m: &mut TripProperties| { &mut m.start_date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_time",
                |m: &TripProperties| { &m.start_time },
                |m: &mut TripProperties| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "shape_id",
                |m: &TripProperties| { &m.shape_id },
                |m: &mut TripProperties| { &mut m.shape_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TripProperties>(
                "TripUpdate.TripProperties",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TripProperties {
        const NAME: &'static str = "TripProperties";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.trip_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.start_date = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.start_time = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.shape_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.trip_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.start_date.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.start_time.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.shape_id.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.trip_id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.start_date.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.start_time.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.shape_id.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TripProperties {
            TripProperties::new()
        }

        fn clear(&mut self) {
            self.trip_id = ::std::option::Option::None;
            self.start_date = ::std::option::Option::None;
            self.start_time = ::std::option::Option::None;
            self.shape_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TripProperties {
            static instance: TripProperties = TripProperties {
                trip_id: ::std::option::Option::None,
                start_date: ::std::option::Option::None,
                start_time: ::std::option::Option::None,
                shape_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TripProperties {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TripUpdate.TripProperties").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TripProperties {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TripProperties {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:transit_realtime.VehiclePosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VehiclePosition {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.trip)
    pub trip: ::protobuf::MessageField<TripDescriptor>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.vehicle)
    pub vehicle: ::protobuf::MessageField<VehicleDescriptor>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.position)
    pub position: ::protobuf::MessageField<Position>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.current_stop_sequence)
    pub current_stop_sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.stop_id)
    pub stop_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.current_status)
    pub current_status: ::std::option::Option<::protobuf::EnumOrUnknown<vehicle_position::VehicleStopStatus>>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.congestion_level)
    pub congestion_level: ::std::option::Option<::protobuf::EnumOrUnknown<vehicle_position::CongestionLevel>>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.occupancy_status)
    pub occupancy_status: ::std::option::Option<::protobuf::EnumOrUnknown<vehicle_position::OccupancyStatus>>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.occupancy_percentage)
    pub occupancy_percentage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.multi_carriage_details)
    pub multi_carriage_details: ::std::vec::Vec<vehicle_position::CarriageDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.VehiclePosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VehiclePosition {
    fn default() -> &'a VehiclePosition {
        <VehiclePosition as ::protobuf::Message>::default_instance()
    }
}

impl VehiclePosition {
    pub fn new() -> VehiclePosition {
        ::std::default::Default::default()
    }

    // optional uint32 current_stop_sequence = 3;

    pub fn current_stop_sequence(&self) -> u32 {
        self.current_stop_sequence.unwrap_or(0)
    }

    pub fn clear_current_stop_sequence(&mut self) {
        self.current_stop_sequence = ::std::option::Option::None;
    }

    pub fn has_current_stop_sequence(&self) -> bool {
        self.current_stop_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_stop_sequence(&mut self, v: u32) {
        self.current_stop_sequence = ::std::option::Option::Some(v);
    }

    // optional string stop_id = 7;

    pub fn stop_id(&self) -> &str {
        match self.stop_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stop_id(&mut self) {
        self.stop_id = ::std::option::Option::None;
    }

    pub fn has_stop_id(&self) -> bool {
        self.stop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_id(&mut self, v: ::std::string::String) {
        self.stop_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop_id(&mut self) -> &mut ::std::string::String {
        if self.stop_id.is_none() {
            self.stop_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stop_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stop_id(&mut self) -> ::std::string::String {
        self.stop_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4;

    pub fn current_status(&self) -> vehicle_position::VehicleStopStatus {
        match self.current_status {
            Some(e) => e.enum_value_or(vehicle_position::VehicleStopStatus::IN_TRANSIT_TO),
            None => vehicle_position::VehicleStopStatus::IN_TRANSIT_TO,
        }
    }

    pub fn clear_current_status(&mut self) {
        self.current_status = ::std::option::Option::None;
    }

    pub fn has_current_status(&self) -> bool {
        self.current_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_status(&mut self, v: vehicle_position::VehicleStopStatus) {
        self.current_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 timestamp = 5;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;

    pub fn congestion_level(&self) -> vehicle_position::CongestionLevel {
        match self.congestion_level {
            Some(e) => e.enum_value_or(vehicle_position::CongestionLevel::UNKNOWN_CONGESTION_LEVEL),
            None => vehicle_position::CongestionLevel::UNKNOWN_CONGESTION_LEVEL,
        }
    }

    pub fn clear_congestion_level(&mut self) {
        self.congestion_level = ::std::option::Option::None;
    }

    pub fn has_congestion_level(&self) -> bool {
        self.congestion_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_congestion_level(&mut self, v: vehicle_position::CongestionLevel) {
        self.congestion_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;

    pub fn occupancy_status(&self) -> vehicle_position::OccupancyStatus {
        match self.occupancy_status {
            Some(e) => e.enum_value_or(vehicle_position::OccupancyStatus::EMPTY),
            None => vehicle_position::OccupancyStatus::EMPTY,
        }
    }

    pub fn clear_occupancy_status(&mut self) {
        self.occupancy_status = ::std::option::Option::None;
    }

    pub fn has_occupancy_status(&self) -> bool {
        self.occupancy_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occupancy_status(&mut self, v: vehicle_position::OccupancyStatus) {
        self.occupancy_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 occupancy_percentage = 10;

    pub fn occupancy_percentage(&self) -> u32 {
        self.occupancy_percentage.unwrap_or(0)
    }

    pub fn clear_occupancy_percentage(&mut self) {
        self.occupancy_percentage = ::std::option::Option::None;
    }

    pub fn has_occupancy_percentage(&self) -> bool {
        self.occupancy_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occupancy_percentage(&mut self, v: u32) {
        self.occupancy_percentage = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TripDescriptor>(
            "trip",
            |m: &VehiclePosition| { &m.trip },
            |m: &mut VehiclePosition| { &mut m.trip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VehicleDescriptor>(
            "vehicle",
            |m: &VehiclePosition| { &m.vehicle },
            |m: &mut VehiclePosition| { &mut m.vehicle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "position",
            |m: &VehiclePosition| { &m.position },
            |m: &mut VehiclePosition| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_stop_sequence",
            |m: &VehiclePosition| { &m.current_stop_sequence },
            |m: &mut VehiclePosition| { &mut m.current_stop_sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_id",
            |m: &VehiclePosition| { &m.stop_id },
            |m: &mut VehiclePosition| { &mut m.stop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_status",
            |m: &VehiclePosition| { &m.current_status },
            |m: &mut VehiclePosition| { &mut m.current_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &VehiclePosition| { &m.timestamp },
            |m: &mut VehiclePosition| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "congestion_level",
            |m: &VehiclePosition| { &m.congestion_level },
            |m: &mut VehiclePosition| { &mut m.congestion_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "occupancy_status",
            |m: &VehiclePosition| { &m.occupancy_status },
            |m: &mut VehiclePosition| { &mut m.occupancy_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "occupancy_percentage",
            |m: &VehiclePosition| { &m.occupancy_percentage },
            |m: &mut VehiclePosition| { &mut m.occupancy_percentage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "multi_carriage_details",
            |m: &VehiclePosition| { &m.multi_carriage_details },
            |m: &mut VehiclePosition| { &mut m.multi_carriage_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VehiclePosition>(
            "VehiclePosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VehiclePosition {
    const NAME: &'static str = "VehiclePosition";

    fn is_initialized(&self) -> bool {
        for v in &self.trip {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vehicle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multi_carriage_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vehicle)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                24 => {
                    self.current_stop_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.stop_id = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.current_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.congestion_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.occupancy_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.occupancy_percentage = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.multi_carriage_details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vehicle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.current_stop_sequence {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.stop_id.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.current_status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.congestion_level {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.occupancy_status {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.occupancy_percentage {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        for value in &self.multi_carriage_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vehicle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.current_stop_sequence {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.stop_id.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.current_status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.congestion_level {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.occupancy_status {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.occupancy_percentage {
            os.write_uint32(10, v)?;
        }
        for v in &self.multi_carriage_details {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VehiclePosition {
        VehiclePosition::new()
    }

    fn clear(&mut self) {
        self.trip.clear();
        self.vehicle.clear();
        self.position.clear();
        self.current_stop_sequence = ::std::option::Option::None;
        self.stop_id = ::std::option::Option::None;
        self.current_status = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.congestion_level = ::std::option::Option::None;
        self.occupancy_status = ::std::option::Option::None;
        self.occupancy_percentage = ::std::option::Option::None;
        self.multi_carriage_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VehiclePosition {
        static instance: VehiclePosition = VehiclePosition {
            trip: ::protobuf::MessageField::none(),
            vehicle: ::protobuf::MessageField::none(),
            position: ::protobuf::MessageField::none(),
            current_stop_sequence: ::std::option::Option::None,
            stop_id: ::std::option::Option::None,
            current_status: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            congestion_level: ::std::option::Option::None,
            occupancy_status: ::std::option::Option::None,
            occupancy_percentage: ::std::option::Option::None,
            multi_carriage_details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VehiclePosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VehiclePosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VehiclePosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VehiclePosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VehiclePosition`
pub mod vehicle_position {
    // @@protoc_insertion_point(message:transit_realtime.VehiclePosition.CarriageDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CarriageDetails {
        // message fields
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.id)
        pub id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.label)
        pub label: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.occupancy_status)
        pub occupancy_status: ::std::option::Option<::protobuf::EnumOrUnknown<OccupancyStatus>>,
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.occupancy_percentage)
        pub occupancy_percentage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.carriage_sequence)
        pub carriage_sequence: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.VehiclePosition.CarriageDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CarriageDetails {
        fn default() -> &'a CarriageDetails {
            <CarriageDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl CarriageDetails {
        pub fn new() -> CarriageDetails {
            ::std::default::Default::default()
        }

        // optional string id = 1;

        pub fn id(&self) -> &str {
            match self.id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: ::std::string::String) {
            self.id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_id(&mut self) -> &mut ::std::string::String {
            if self.id.is_none() {
                self.id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.id.as_mut().unwrap()
        }

        // Take field
        pub fn take_id(&mut self) -> ::std::string::String {
            self.id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string label = 2;

        pub fn label(&self) -> &str {
            match self.label.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_label(&mut self) {
            self.label = ::std::option::Option::None;
        }

        pub fn has_label(&self) -> bool {
            self.label.is_some()
        }

        // Param is passed by value, moved
        pub fn set_label(&mut self, v: ::std::string::String) {
            self.label = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_label(&mut self) -> &mut ::std::string::String {
            if self.label.is_none() {
                self.label = ::std::option::Option::Some(::std::string::String::new());
            }
            self.label.as_mut().unwrap()
        }

        // Take field
        pub fn take_label(&mut self) -> ::std::string::String {
            self.label.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3;

        pub fn occupancy_status(&self) -> OccupancyStatus {
            match self.occupancy_status {
                Some(e) => e.enum_value_or(OccupancyStatus::NO_DATA_AVAILABLE),
                None => OccupancyStatus::NO_DATA_AVAILABLE,
            }
        }

        pub fn clear_occupancy_status(&mut self) {
            self.occupancy_status = ::std::option::Option::None;
        }

        pub fn has_occupancy_status(&self) -> bool {
            self.occupancy_status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_occupancy_status(&mut self, v: OccupancyStatus) {
            self.occupancy_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional int32 occupancy_percentage = 4;

        pub fn occupancy_percentage(&self) -> i32 {
            self.occupancy_percentage.unwrap_or(-1i32)
        }

        pub fn clear_occupancy_percentage(&mut self) {
            self.occupancy_percentage = ::std::option::Option::None;
        }

        pub fn has_occupancy_percentage(&self) -> bool {
            self.occupancy_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_occupancy_percentage(&mut self, v: i32) {
            self.occupancy_percentage = ::std::option::Option::Some(v);
        }

        // optional uint32 carriage_sequence = 5;

        pub fn carriage_sequence(&self) -> u32 {
            self.carriage_sequence.unwrap_or(0)
        }

        pub fn clear_carriage_sequence(&mut self) {
            self.carriage_sequence = ::std::option::Option::None;
        }

        pub fn has_carriage_sequence(&self) -> bool {
            self.carriage_sequence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_carriage_sequence(&mut self, v: u32) {
            self.carriage_sequence = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &CarriageDetails| { &m.id },
                |m: &mut CarriageDetails| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "label",
                |m: &CarriageDetails| { &m.label },
                |m: &mut CarriageDetails| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "occupancy_status",
                |m: &CarriageDetails| { &m.occupancy_status },
                |m: &mut CarriageDetails| { &mut m.occupancy_status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "occupancy_percentage",
                |m: &CarriageDetails| { &m.occupancy_percentage },
                |m: &mut CarriageDetails| { &mut m.occupancy_percentage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "carriage_sequence",
                |m: &CarriageDetails| { &m.carriage_sequence },
                |m: &mut CarriageDetails| { &mut m.carriage_sequence },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CarriageDetails>(
                "VehiclePosition.CarriageDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CarriageDetails {
        const NAME: &'static str = "CarriageDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.label = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.occupancy_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.occupancy_percentage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.carriage_sequence = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.label.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.occupancy_status {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.occupancy_percentage {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.carriage_sequence {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.label.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.occupancy_status {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.occupancy_percentage {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.carriage_sequence {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CarriageDetails {
            CarriageDetails::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.label = ::std::option::Option::None;
            self.occupancy_status = ::std::option::Option::None;
            self.occupancy_percentage = ::std::option::Option::None;
            self.carriage_sequence = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CarriageDetails {
            static instance: CarriageDetails = CarriageDetails {
                id: ::std::option::Option::None,
                label: ::std::option::Option::None,
                occupancy_status: ::std::option::Option::None,
                occupancy_percentage: ::std::option::Option::None,
                carriage_sequence: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CarriageDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("VehiclePosition.CarriageDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CarriageDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CarriageDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.VehiclePosition.VehicleStopStatus)
    pub enum VehicleStopStatus {
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.VehicleStopStatus.INCOMING_AT)
        INCOMING_AT = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.VehicleStopStatus.STOPPED_AT)
        STOPPED_AT = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.VehicleStopStatus.IN_TRANSIT_TO)
        IN_TRANSIT_TO = 2,
    }

    impl ::protobuf::Enum for VehicleStopStatus {
        const NAME: &'static str = "VehicleStopStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<VehicleStopStatus> {
            match value {
                0 => ::std::option::Option::Some(VehicleStopStatus::INCOMING_AT),
                1 => ::std::option::Option::Some(VehicleStopStatus::STOPPED_AT),
                2 => ::std::option::Option::Some(VehicleStopStatus::IN_TRANSIT_TO),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<VehicleStopStatus> {
            match str {
                "INCOMING_AT" => ::std::option::Option::Some(VehicleStopStatus::INCOMING_AT),
                "STOPPED_AT" => ::std::option::Option::Some(VehicleStopStatus::STOPPED_AT),
                "IN_TRANSIT_TO" => ::std::option::Option::Some(VehicleStopStatus::IN_TRANSIT_TO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [VehicleStopStatus] = &[
            VehicleStopStatus::INCOMING_AT,
            VehicleStopStatus::STOPPED_AT,
            VehicleStopStatus::IN_TRANSIT_TO,
        ];
    }

    impl ::protobuf::EnumFull for VehicleStopStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VehiclePosition.VehicleStopStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for VehicleStopStatus {
        fn default() -> Self {
            VehicleStopStatus::INCOMING_AT
        }
    }

    impl VehicleStopStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VehicleStopStatus>("VehiclePosition.VehicleStopStatus")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.VehiclePosition.CongestionLevel)
    pub enum CongestionLevel {
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.UNKNOWN_CONGESTION_LEVEL)
        UNKNOWN_CONGESTION_LEVEL = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.RUNNING_SMOOTHLY)
        RUNNING_SMOOTHLY = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.STOP_AND_GO)
        STOP_AND_GO = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.CONGESTION)
        CONGESTION = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.SEVERE_CONGESTION)
        SEVERE_CONGESTION = 4,
    }

    impl ::protobuf::Enum for CongestionLevel {
        const NAME: &'static str = "CongestionLevel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CongestionLevel> {
            match value {
                0 => ::std::option::Option::Some(CongestionLevel::UNKNOWN_CONGESTION_LEVEL),
                1 => ::std::option::Option::Some(CongestionLevel::RUNNING_SMOOTHLY),
                2 => ::std::option::Option::Some(CongestionLevel::STOP_AND_GO),
                3 => ::std::option::Option::Some(CongestionLevel::CONGESTION),
                4 => ::std::option::Option::Some(CongestionLevel::SEVERE_CONGESTION),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<CongestionLevel> {
            match str {
                "UNKNOWN_CONGESTION_LEVEL" => ::std::option::Option::Some(CongestionLevel::UNKNOWN_CONGESTION_LEVEL),
                "RUNNING_SMOOTHLY" => ::std::option::Option::Some(CongestionLevel::RUNNING_SMOOTHLY),
                "STOP_AND_GO" => ::std::option::Option::Some(CongestionLevel::STOP_AND_GO),
                "CONGESTION" => ::std::option::Option::Some(CongestionLevel::CONGESTION),
                "SEVERE_CONGESTION" => ::std::option::Option::Some(CongestionLevel::SEVERE_CONGESTION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CongestionLevel] = &[
            CongestionLevel::UNKNOWN_CONGESTION_LEVEL,
            CongestionLevel::RUNNING_SMOOTHLY,
            CongestionLevel::STOP_AND_GO,
            CongestionLevel::CONGESTION,
            CongestionLevel::SEVERE_CONGESTION,
        ];
    }

    impl ::protobuf::EnumFull for CongestionLevel {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VehiclePosition.CongestionLevel").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CongestionLevel {
        fn default() -> Self {
            CongestionLevel::UNKNOWN_CONGESTION_LEVEL
        }
    }

    impl CongestionLevel {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CongestionLevel>("VehiclePosition.CongestionLevel")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.VehiclePosition.OccupancyStatus)
    pub enum OccupancyStatus {
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.EMPTY)
        EMPTY = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.MANY_SEATS_AVAILABLE)
        MANY_SEATS_AVAILABLE = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.FEW_SEATS_AVAILABLE)
        FEW_SEATS_AVAILABLE = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.STANDING_ROOM_ONLY)
        STANDING_ROOM_ONLY = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.CRUSHED_STANDING_ROOM_ONLY)
        CRUSHED_STANDING_ROOM_ONLY = 4,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.FULL)
        FULL = 5,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.NOT_ACCEPTING_PASSENGERS)
        NOT_ACCEPTING_PASSENGERS = 6,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.NO_DATA_AVAILABLE)
        NO_DATA_AVAILABLE = 7,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.NOT_BOARDABLE)
        NOT_BOARDABLE = 8,
    }

    impl ::protobuf::Enum for OccupancyStatus {
        const NAME: &'static str = "OccupancyStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OccupancyStatus> {
            match value {
                0 => ::std::option::Option::Some(OccupancyStatus::EMPTY),
                1 => ::std::option::Option::Some(OccupancyStatus::MANY_SEATS_AVAILABLE),
                2 => ::std::option::Option::Some(OccupancyStatus::FEW_SEATS_AVAILABLE),
                3 => ::std::option::Option::Some(OccupancyStatus::STANDING_ROOM_ONLY),
                4 => ::std::option::Option::Some(OccupancyStatus::CRUSHED_STANDING_ROOM_ONLY),
                5 => ::std::option::Option::Some(OccupancyStatus::FULL),
                6 => ::std::option::Option::Some(OccupancyStatus::NOT_ACCEPTING_PASSENGERS),
                7 => ::std::option::Option::Some(OccupancyStatus::NO_DATA_AVAILABLE),
                8 => ::std::option::Option::Some(OccupancyStatus::NOT_BOARDABLE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<OccupancyStatus> {
            match str {
                "EMPTY" => ::std::option::Option::Some(OccupancyStatus::EMPTY),
                "MANY_SEATS_AVAILABLE" => ::std::option::Option::Some(OccupancyStatus::MANY_SEATS_AVAILABLE),
                "FEW_SEATS_AVAILABLE" => ::std::option::Option::Some(OccupancyStatus::FEW_SEATS_AVAILABLE),
                "STANDING_ROOM_ONLY" => ::std::option::Option::Some(OccupancyStatus::STANDING_ROOM_ONLY),
                "CRUSHED_STANDING_ROOM_ONLY" => ::std::option::Option::Some(OccupancyStatus::CRUSHED_STANDING_ROOM_ONLY),
                "FULL" => ::std::option::Option::Some(OccupancyStatus::FULL),
                "NOT_ACCEPTING_PASSENGERS" => ::std::option::Option::Some(OccupancyStatus::NOT_ACCEPTING_PASSENGERS),
                "NO_DATA_AVAILABLE" => ::std::option::Option::Some(OccupancyStatus::NO_DATA_AVAILABLE),
                "NOT_BOARDABLE" => ::std::option::Option::Some(OccupancyStatus::NOT_BOARDABLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OccupancyStatus] = &[
            OccupancyStatus::EMPTY,
            OccupancyStatus::MANY_SEATS_AVAILABLE,
            OccupancyStatus::FEW_SEATS_AVAILABLE,
            OccupancyStatus::STANDING_ROOM_ONLY,
            OccupancyStatus::CRUSHED_STANDING_ROOM_ONLY,
            OccupancyStatus::FULL,
            OccupancyStatus::NOT_ACCEPTING_PASSENGERS,
            OccupancyStatus::NO_DATA_AVAILABLE,
            OccupancyStatus::NOT_BOARDABLE,
        ];
    }

    impl ::protobuf::EnumFull for OccupancyStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VehiclePosition.OccupancyStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for OccupancyStatus {
        fn default() -> Self {
            OccupancyStatus::EMPTY
        }
    }

    impl OccupancyStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OccupancyStatus>("VehiclePosition.OccupancyStatus")
        }
    }
}

// @@protoc_insertion_point(message:transit_realtime.Alert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Alert {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.Alert.active_period)
    pub active_period: ::std::vec::Vec<TimeRange>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.informed_entity)
    pub informed_entity: ::std::vec::Vec<EntitySelector>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.cause)
    pub cause: ::std::option::Option<::protobuf::EnumOrUnknown<alert::Cause>>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.effect)
    pub effect: ::std::option::Option<::protobuf::EnumOrUnknown<alert::Effect>>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.url)
    pub url: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.header_text)
    pub header_text: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.description_text)
    pub description_text: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.tts_header_text)
    pub tts_header_text: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.tts_description_text)
    pub tts_description_text: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.severity_level)
    pub severity_level: ::std::option::Option<::protobuf::EnumOrUnknown<alert::SeverityLevel>>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.image)
    pub image: ::protobuf::MessageField<TranslatedImage>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.image_alternative_text)
    pub image_alternative_text: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.cause_detail)
    pub cause_detail: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.effect_detail)
    pub effect_detail: ::protobuf::MessageField<TranslatedString>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.Alert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Alert {
    fn default() -> &'a Alert {
        <Alert as ::protobuf::Message>::default_instance()
    }
}

impl Alert {
    pub fn new() -> Alert {
        ::std::default::Default::default()
    }

    // optional .transit_realtime.Alert.Cause cause = 6;

    pub fn cause(&self) -> alert::Cause {
        match self.cause {
            Some(e) => e.enum_value_or(alert::Cause::UNKNOWN_CAUSE),
            None => alert::Cause::UNKNOWN_CAUSE,
        }
    }

    pub fn clear_cause(&mut self) {
        self.cause = ::std::option::Option::None;
    }

    pub fn has_cause(&self) -> bool {
        self.cause.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cause(&mut self, v: alert::Cause) {
        self.cause = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .transit_realtime.Alert.Effect effect = 7;

    pub fn effect(&self) -> alert::Effect {
        match self.effect {
            Some(e) => e.enum_value_or(alert::Effect::UNKNOWN_EFFECT),
            None => alert::Effect::UNKNOWN_EFFECT,
        }
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: alert::Effect) {
        self.effect = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .transit_realtime.Alert.SeverityLevel severity_level = 14;

    pub fn severity_level(&self) -> alert::SeverityLevel {
        match self.severity_level {
            Some(e) => e.enum_value_or(alert::SeverityLevel::UNKNOWN_SEVERITY),
            None => alert::SeverityLevel::UNKNOWN_SEVERITY,
        }
    }

    pub fn clear_severity_level(&mut self) {
        self.severity_level = ::std::option::Option::None;
    }

    pub fn has_severity_level(&self) -> bool {
        self.severity_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity_level(&mut self, v: alert::SeverityLevel) {
        self.severity_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "active_period",
            |m: &Alert| { &m.active_period },
            |m: &mut Alert| { &mut m.active_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "informed_entity",
            |m: &Alert| { &m.informed_entity },
            |m: &mut Alert| { &mut m.informed_entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cause",
            |m: &Alert| { &m.cause },
            |m: &mut Alert| { &mut m.cause },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &Alert| { &m.effect },
            |m: &mut Alert| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "url",
            |m: &Alert| { &m.url },
            |m: &mut Alert| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "header_text",
            |m: &Alert| { &m.header_text },
            |m: &mut Alert| { &mut m.header_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "description_text",
            |m: &Alert| { &m.description_text },
            |m: &mut Alert| { &mut m.description_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "tts_header_text",
            |m: &Alert| { &m.tts_header_text },
            |m: &mut Alert| { &mut m.tts_header_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "tts_description_text",
            |m: &Alert| { &m.tts_description_text },
            |m: &mut Alert| { &mut m.tts_description_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "severity_level",
            |m: &Alert| { &m.severity_level },
            |m: &mut Alert| { &mut m.severity_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedImage>(
            "image",
            |m: &Alert| { &m.image },
            |m: &mut Alert| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "image_alternative_text",
            |m: &Alert| { &m.image_alternative_text },
            |m: &mut Alert| { &mut m.image_alternative_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "cause_detail",
            |m: &Alert| { &m.cause_detail },
            |m: &mut Alert| { &mut m.cause_detail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "effect_detail",
            |m: &Alert| { &m.effect_detail },
            |m: &mut Alert| { &mut m.effect_detail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Alert>(
            "Alert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Alert {
    const NAME: &'static str = "Alert";

    fn is_initialized(&self) -> bool {
        for v in &self.active_period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.informed_entity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.url {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.header_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.description_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tts_header_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tts_description_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_alternative_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cause_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.effect_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.active_period.push(is.read_message()?);
                },
                42 => {
                    self.informed_entity.push(is.read_message()?);
                },
                48 => {
                    self.cause = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.effect = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.url)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header_text)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.description_text)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tts_header_text)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tts_description_text)?;
                },
                112 => {
                    self.severity_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image_alternative_text)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cause_detail)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.effect_detail)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.active_period {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.informed_entity {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cause {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.effect {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.header_text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.description_text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tts_header_text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tts_description_text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.severity_level {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image_alternative_text.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cause_detail.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.effect_detail.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.active_period {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.informed_entity {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.cause {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.effect {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.url.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.header_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.description_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.tts_header_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.tts_description_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.severity_level {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.image_alternative_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.cause_detail.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.effect_detail.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Alert {
        Alert::new()
    }

    fn clear(&mut self) {
        self.active_period.clear();
        self.informed_entity.clear();
        self.cause = ::std::option::Option::None;
        self.effect = ::std::option::Option::None;
        self.url.clear();
        self.header_text.clear();
        self.description_text.clear();
        self.tts_header_text.clear();
        self.tts_description_text.clear();
        self.severity_level = ::std::option::Option::None;
        self.image.clear();
        self.image_alternative_text.clear();
        self.cause_detail.clear();
        self.effect_detail.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Alert {
        static instance: Alert = Alert {
            active_period: ::std::vec::Vec::new(),
            informed_entity: ::std::vec::Vec::new(),
            cause: ::std::option::Option::None,
            effect: ::std::option::Option::None,
            url: ::protobuf::MessageField::none(),
            header_text: ::protobuf::MessageField::none(),
            description_text: ::protobuf::MessageField::none(),
            tts_header_text: ::protobuf::MessageField::none(),
            tts_description_text: ::protobuf::MessageField::none(),
            severity_level: ::std::option::Option::None,
            image: ::protobuf::MessageField::none(),
            image_alternative_text: ::protobuf::MessageField::none(),
            cause_detail: ::protobuf::MessageField::none(),
            effect_detail: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Alert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Alert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Alert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Alert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Alert`
pub mod alert {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.Alert.Cause)
    pub enum Cause {
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.UNKNOWN_CAUSE)
        UNKNOWN_CAUSE = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.OTHER_CAUSE)
        OTHER_CAUSE = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.TECHNICAL_PROBLEM)
        TECHNICAL_PROBLEM = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.STRIKE)
        STRIKE = 4,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.DEMONSTRATION)
        DEMONSTRATION = 5,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.ACCIDENT)
        ACCIDENT = 6,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.HOLIDAY)
        HOLIDAY = 7,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.WEATHER)
        WEATHER = 8,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.MAINTENANCE)
        MAINTENANCE = 9,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.CONSTRUCTION)
        CONSTRUCTION = 10,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.POLICE_ACTIVITY)
        POLICE_ACTIVITY = 11,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.MEDICAL_EMERGENCY)
        MEDICAL_EMERGENCY = 12,
    }

    impl ::protobuf::Enum for Cause {
        const NAME: &'static str = "Cause";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Cause> {
            match value {
                1 => ::std::option::Option::Some(Cause::UNKNOWN_CAUSE),
                2 => ::std::option::Option::Some(Cause::OTHER_CAUSE),
                3 => ::std::option::Option::Some(Cause::TECHNICAL_PROBLEM),
                4 => ::std::option::Option::Some(Cause::STRIKE),
                5 => ::std::option::Option::Some(Cause::DEMONSTRATION),
                6 => ::std::option::Option::Some(Cause::ACCIDENT),
                7 => ::std::option::Option::Some(Cause::HOLIDAY),
                8 => ::std::option::Option::Some(Cause::WEATHER),
                9 => ::std::option::Option::Some(Cause::MAINTENANCE),
                10 => ::std::option::Option::Some(Cause::CONSTRUCTION),
                11 => ::std::option::Option::Some(Cause::POLICE_ACTIVITY),
                12 => ::std::option::Option::Some(Cause::MEDICAL_EMERGENCY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Cause> {
            match str {
                "UNKNOWN_CAUSE" => ::std::option::Option::Some(Cause::UNKNOWN_CAUSE),
                "OTHER_CAUSE" => ::std::option::Option::Some(Cause::OTHER_CAUSE),
                "TECHNICAL_PROBLEM" => ::std::option::Option::Some(Cause::TECHNICAL_PROBLEM),
                "STRIKE" => ::std::option::Option::Some(Cause::STRIKE),
                "DEMONSTRATION" => ::std::option::Option::Some(Cause::DEMONSTRATION),
                "ACCIDENT" => ::std::option::Option::Some(Cause::ACCIDENT),
                "HOLIDAY" => ::std::option::Option::Some(Cause::HOLIDAY),
                "WEATHER" => ::std::option::Option::Some(Cause::WEATHER),
                "MAINTENANCE" => ::std::option::Option::Some(Cause::MAINTENANCE),
                "CONSTRUCTION" => ::std::option::Option::Some(Cause::CONSTRUCTION),
                "POLICE_ACTIVITY" => ::std::option::Option::Some(Cause::POLICE_ACTIVITY),
                "MEDICAL_EMERGENCY" => ::std::option::Option::Some(Cause::MEDICAL_EMERGENCY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Cause] = &[
            Cause::UNKNOWN_CAUSE,
            Cause::OTHER_CAUSE,
            Cause::TECHNICAL_PROBLEM,
            Cause::STRIKE,
            Cause::DEMONSTRATION,
            Cause::ACCIDENT,
            Cause::HOLIDAY,
            Cause::WEATHER,
            Cause::MAINTENANCE,
            Cause::CONSTRUCTION,
            Cause::POLICE_ACTIVITY,
            Cause::MEDICAL_EMERGENCY,
        ];
    }

    impl ::protobuf::EnumFull for Cause {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Alert.Cause").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Cause::UNKNOWN_CAUSE => 0,
                Cause::OTHER_CAUSE => 1,
                Cause::TECHNICAL_PROBLEM => 2,
                Cause::STRIKE => 3,
                Cause::DEMONSTRATION => 4,
                Cause::ACCIDENT => 5,
                Cause::HOLIDAY => 6,
                Cause::WEATHER => 7,
                Cause::MAINTENANCE => 8,
                Cause::CONSTRUCTION => 9,
                Cause::POLICE_ACTIVITY => 10,
                Cause::MEDICAL_EMERGENCY => 11,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Cause {
        fn default() -> Self {
            Cause::UNKNOWN_CAUSE
        }
    }

    impl Cause {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Cause>("Alert.Cause")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.Alert.Effect)
    pub enum Effect {
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.NO_SERVICE)
        NO_SERVICE = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.REDUCED_SERVICE)
        REDUCED_SERVICE = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.SIGNIFICANT_DELAYS)
        SIGNIFICANT_DELAYS = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.DETOUR)
        DETOUR = 4,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.ADDITIONAL_SERVICE)
        ADDITIONAL_SERVICE = 5,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.MODIFIED_SERVICE)
        MODIFIED_SERVICE = 6,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.OTHER_EFFECT)
        OTHER_EFFECT = 7,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.UNKNOWN_EFFECT)
        UNKNOWN_EFFECT = 8,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.STOP_MOVED)
        STOP_MOVED = 9,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.NO_EFFECT)
        NO_EFFECT = 10,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.ACCESSIBILITY_ISSUE)
        ACCESSIBILITY_ISSUE = 11,
    }

    impl ::protobuf::Enum for Effect {
        const NAME: &'static str = "Effect";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Effect> {
            match value {
                1 => ::std::option::Option::Some(Effect::NO_SERVICE),
                2 => ::std::option::Option::Some(Effect::REDUCED_SERVICE),
                3 => ::std::option::Option::Some(Effect::SIGNIFICANT_DELAYS),
                4 => ::std::option::Option::Some(Effect::DETOUR),
                5 => ::std::option::Option::Some(Effect::ADDITIONAL_SERVICE),
                6 => ::std::option::Option::Some(Effect::MODIFIED_SERVICE),
                7 => ::std::option::Option::Some(Effect::OTHER_EFFECT),
                8 => ::std::option::Option::Some(Effect::UNKNOWN_EFFECT),
                9 => ::std::option::Option::Some(Effect::STOP_MOVED),
                10 => ::std::option::Option::Some(Effect::NO_EFFECT),
                11 => ::std::option::Option::Some(Effect::ACCESSIBILITY_ISSUE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Effect> {
            match str {
                "NO_SERVICE" => ::std::option::Option::Some(Effect::NO_SERVICE),
                "REDUCED_SERVICE" => ::std::option::Option::Some(Effect::REDUCED_SERVICE),
                "SIGNIFICANT_DELAYS" => ::std::option::Option::Some(Effect::SIGNIFICANT_DELAYS),
                "DETOUR" => ::std::option::Option::Some(Effect::DETOUR),
                "ADDITIONAL_SERVICE" => ::std::option::Option::Some(Effect::ADDITIONAL_SERVICE),
                "MODIFIED_SERVICE" => ::std::option::Option::Some(Effect::MODIFIED_SERVICE),
                "OTHER_EFFECT" => ::std::option::Option::Some(Effect::OTHER_EFFECT),
                "UNKNOWN_EFFECT" => ::std::option::Option::Some(Effect::UNKNOWN_EFFECT),
                "STOP_MOVED" => ::std::option::Option::Some(Effect::STOP_MOVED),
                "NO_EFFECT" => ::std::option::Option::Some(Effect::NO_EFFECT),
                "ACCESSIBILITY_ISSUE" => ::std::option::Option::Some(Effect::ACCESSIBILITY_ISSUE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Effect] = &[
            Effect::NO_SERVICE,
            Effect::REDUCED_SERVICE,
            Effect::SIGNIFICANT_DELAYS,
            Effect::DETOUR,
            Effect::ADDITIONAL_SERVICE,
            Effect::MODIFIED_SERVICE,
            Effect::OTHER_EFFECT,
            Effect::UNKNOWN_EFFECT,
            Effect::STOP_MOVED,
            Effect::NO_EFFECT,
            Effect::ACCESSIBILITY_ISSUE,
        ];
    }

    impl ::protobuf::EnumFull for Effect {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Alert.Effect").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Effect::NO_SERVICE => 0,
                Effect::REDUCED_SERVICE => 1,
                Effect::SIGNIFICANT_DELAYS => 2,
                Effect::DETOUR => 3,
                Effect::ADDITIONAL_SERVICE => 4,
                Effect::MODIFIED_SERVICE => 5,
                Effect::OTHER_EFFECT => 6,
                Effect::UNKNOWN_EFFECT => 7,
                Effect::STOP_MOVED => 8,
                Effect::NO_EFFECT => 9,
                Effect::ACCESSIBILITY_ISSUE => 10,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Effect {
        fn default() -> Self {
            Effect::NO_SERVICE
        }
    }

    impl Effect {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Effect>("Alert.Effect")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.Alert.SeverityLevel)
    pub enum SeverityLevel {
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.SeverityLevel.UNKNOWN_SEVERITY)
        UNKNOWN_SEVERITY = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.SeverityLevel.INFO)
        INFO = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.SeverityLevel.WARNING)
        WARNING = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.SeverityLevel.SEVERE)
        SEVERE = 4,
    }

    impl ::protobuf::Enum for SeverityLevel {
        const NAME: &'static str = "SeverityLevel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SeverityLevel> {
            match value {
                1 => ::std::option::Option::Some(SeverityLevel::UNKNOWN_SEVERITY),
                2 => ::std::option::Option::Some(SeverityLevel::INFO),
                3 => ::std::option::Option::Some(SeverityLevel::WARNING),
                4 => ::std::option::Option::Some(SeverityLevel::SEVERE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SeverityLevel> {
            match str {
                "UNKNOWN_SEVERITY" => ::std::option::Option::Some(SeverityLevel::UNKNOWN_SEVERITY),
                "INFO" => ::std::option::Option::Some(SeverityLevel::INFO),
                "WARNING" => ::std::option::Option::Some(SeverityLevel::WARNING),
                "SEVERE" => ::std::option::Option::Some(SeverityLevel::SEVERE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SeverityLevel] = &[
            SeverityLevel::UNKNOWN_SEVERITY,
            SeverityLevel::INFO,
            SeverityLevel::WARNING,
            SeverityLevel::SEVERE,
        ];
    }

    impl ::protobuf::EnumFull for SeverityLevel {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Alert.SeverityLevel").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                SeverityLevel::UNKNOWN_SEVERITY => 0,
                SeverityLevel::INFO => 1,
                SeverityLevel::WARNING => 2,
                SeverityLevel::SEVERE => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for SeverityLevel {
        fn default() -> Self {
            SeverityLevel::UNKNOWN_SEVERITY
        }
    }

    impl SeverityLevel {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SeverityLevel>("Alert.SeverityLevel")
        }
    }
}

// @@protoc_insertion_point(message:transit_realtime.TimeRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TimeRange {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.TimeRange.start)
    pub start: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:transit_realtime.TimeRange.end)
    pub end: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TimeRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeRange {
    fn default() -> &'a TimeRange {
        <TimeRange as ::protobuf::Message>::default_instance()
    }
}

impl TimeRange {
    pub fn new() -> TimeRange {
        ::std::default::Default::default()
    }

    // optional uint64 start = 1;

    pub fn start(&self) -> u64 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: u64) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional uint64 end = 2;

    pub fn end(&self) -> u64 {
        self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u64) {
        self.end = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &TimeRange| { &m.start },
            |m: &mut TimeRange| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end",
            |m: &TimeRange| { &m.end },
            |m: &mut TimeRange| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeRange>(
            "TimeRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeRange {
    const NAME: &'static str = "TimeRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.end = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.end {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeRange {
        TimeRange::new()
    }

    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeRange {
        static instance: TimeRange = TimeRange {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:transit_realtime.Position)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Position {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.Position.latitude)
    pub latitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:transit_realtime.Position.longitude)
    pub longitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:transit_realtime.Position.bearing)
    pub bearing: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:transit_realtime.Position.odometer)
    pub odometer: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:transit_realtime.Position.speed)
    pub speed: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.Position.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    // required float latitude = 1;

    pub fn latitude(&self) -> f32 {
        self.latitude.unwrap_or(0.)
    }

    pub fn clear_latitude(&mut self) {
        self.latitude = ::std::option::Option::None;
    }

    pub fn has_latitude(&self) -> bool {
        self.latitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latitude(&mut self, v: f32) {
        self.latitude = ::std::option::Option::Some(v);
    }

    // required float longitude = 2;

    pub fn longitude(&self) -> f32 {
        self.longitude.unwrap_or(0.)
    }

    pub fn clear_longitude(&mut self) {
        self.longitude = ::std::option::Option::None;
    }

    pub fn has_longitude(&self) -> bool {
        self.longitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_longitude(&mut self, v: f32) {
        self.longitude = ::std::option::Option::Some(v);
    }

    // optional float bearing = 3;

    pub fn bearing(&self) -> f32 {
        self.bearing.unwrap_or(0.)
    }

    pub fn clear_bearing(&mut self) {
        self.bearing = ::std::option::Option::None;
    }

    pub fn has_bearing(&self) -> bool {
        self.bearing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bearing(&mut self, v: f32) {
        self.bearing = ::std::option::Option::Some(v);
    }

    // optional double odometer = 4;

    pub fn odometer(&self) -> f64 {
        self.odometer.unwrap_or(0.)
    }

    pub fn clear_odometer(&mut self) {
        self.odometer = ::std::option::Option::None;
    }

    pub fn has_odometer(&self) -> bool {
        self.odometer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_odometer(&mut self, v: f64) {
        self.odometer = ::std::option::Option::Some(v);
    }

    // optional float speed = 5;

    pub fn speed(&self) -> f32 {
        self.speed.unwrap_or(0.)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "latitude",
            |m: &Position| { &m.latitude },
            |m: &mut Position| { &mut m.latitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "longitude",
            |m: &Position| { &m.longitude },
            |m: &mut Position| { &mut m.longitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bearing",
            |m: &Position| { &m.bearing },
            |m: &mut Position| { &mut m.bearing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "odometer",
            |m: &Position| { &m.odometer },
            |m: &mut Position| { &mut m.odometer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speed",
            |m: &Position| { &m.speed },
            |m: &mut Position| { &mut m.speed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
            "Position",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Position {
    const NAME: &'static str = "Position";

    fn is_initialized(&self) -> bool {
        if self.latitude.is_none() {
            return false;
        }
        if self.longitude.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.latitude = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.longitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.bearing = ::std::option::Option::Some(is.read_float()?);
                },
                33 => {
                    self.odometer = ::std::option::Option::Some(is.read_double()?);
                },
                45 => {
                    self.speed = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.latitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.longitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bearing {
            my_size += 1 + 4;
        }
        if let Some(v) = self.odometer {
            my_size += 1 + 8;
        }
        if let Some(v) = self.speed {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.latitude {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.longitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.bearing {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.odometer {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.speed {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Position {
        Position::new()
    }

    fn clear(&mut self) {
        self.latitude = ::std::option::Option::None;
        self.longitude = ::std::option::Option::None;
        self.bearing = ::std::option::Option::None;
        self.odometer = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Position {
        static instance: Position = Position {
            latitude: ::std::option::Option::None,
            longitude: ::std::option::Option::None,
            bearing: ::std::option::Option::None,
            odometer: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Position {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Position").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:transit_realtime.TripDescriptor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TripDescriptor {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.trip_id)
    pub trip_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.route_id)
    pub route_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.direction_id)
    pub direction_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.start_time)
    pub start_time: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.start_date)
    pub start_date: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.schedule_relationship)
    pub schedule_relationship: ::std::option::Option<::protobuf::EnumOrUnknown<trip_descriptor::ScheduleRelationship>>,
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.modified_trip)
    pub modified_trip: ::protobuf::MessageField<trip_descriptor::ModifiedTripSelector>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TripDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TripDescriptor {
    fn default() -> &'a TripDescriptor {
        <TripDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl TripDescriptor {
    pub fn new() -> TripDescriptor {
        ::std::default::Default::default()
    }

    // optional string trip_id = 1;

    pub fn trip_id(&self) -> &str {
        match self.trip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_trip_id(&mut self) {
        self.trip_id = ::std::option::Option::None;
    }

    pub fn has_trip_id(&self) -> bool {
        self.trip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trip_id(&mut self, v: ::std::string::String) {
        self.trip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trip_id(&mut self) -> &mut ::std::string::String {
        if self.trip_id.is_none() {
            self.trip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.trip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_trip_id(&mut self) -> ::std::string::String {
        self.trip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string route_id = 5;

    pub fn route_id(&self) -> &str {
        match self.route_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_route_id(&mut self) {
        self.route_id = ::std::option::Option::None;
    }

    pub fn has_route_id(&self) -> bool {
        self.route_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_id(&mut self, v: ::std::string::String) {
        self.route_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_id(&mut self) -> &mut ::std::string::String {
        if self.route_id.is_none() {
            self.route_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.route_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_id(&mut self) -> ::std::string::String {
        self.route_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 direction_id = 6;

    pub fn direction_id(&self) -> u32 {
        self.direction_id.unwrap_or(0)
    }

    pub fn clear_direction_id(&mut self) {
        self.direction_id = ::std::option::Option::None;
    }

    pub fn has_direction_id(&self) -> bool {
        self.direction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction_id(&mut self, v: u32) {
        self.direction_id = ::std::option::Option::Some(v);
    }

    // optional string start_time = 2;

    pub fn start_time(&self) -> &str {
        match self.start_time.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::std::string::String) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::std::string::String {
        if self.start_time.is_none() {
            self.start_time = ::std::option::Option::Some(::std::string::String::new());
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::std::string::String {
        self.start_time.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string start_date = 3;

    pub fn start_date(&self) -> &str {
        match self.start_date.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_start_date(&mut self) {
        self.start_date = ::std::option::Option::None;
    }

    pub fn has_start_date(&self) -> bool {
        self.start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_date(&mut self, v: ::std::string::String) {
        self.start_date = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_date(&mut self) -> &mut ::std::string::String {
        if self.start_date.is_none() {
            self.start_date = ::std::option::Option::Some(::std::string::String::new());
        }
        self.start_date.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_date(&mut self) -> ::std::string::String {
        self.start_date.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;

    pub fn schedule_relationship(&self) -> trip_descriptor::ScheduleRelationship {
        match self.schedule_relationship {
            Some(e) => e.enum_value_or(trip_descriptor::ScheduleRelationship::SCHEDULED),
            None => trip_descriptor::ScheduleRelationship::SCHEDULED,
        }
    }

    pub fn clear_schedule_relationship(&mut self) {
        self.schedule_relationship = ::std::option::Option::None;
    }

    pub fn has_schedule_relationship(&self) -> bool {
        self.schedule_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule_relationship(&mut self, v: trip_descriptor::ScheduleRelationship) {
        self.schedule_relationship = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trip_id",
            |m: &TripDescriptor| { &m.trip_id },
            |m: &mut TripDescriptor| { &mut m.trip_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "route_id",
            |m: &TripDescriptor| { &m.route_id },
            |m: &mut TripDescriptor| { &mut m.route_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "direction_id",
            |m: &TripDescriptor| { &m.direction_id },
            |m: &mut TripDescriptor| { &mut m.direction_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &TripDescriptor| { &m.start_time },
            |m: &mut TripDescriptor| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_date",
            |m: &TripDescriptor| { &m.start_date },
            |m: &mut TripDescriptor| { &mut m.start_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "schedule_relationship",
            |m: &TripDescriptor| { &m.schedule_relationship },
            |m: &mut TripDescriptor| { &mut m.schedule_relationship },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, trip_descriptor::ModifiedTripSelector>(
            "modified_trip",
            |m: &TripDescriptor| { &m.modified_trip },
            |m: &mut TripDescriptor| { &mut m.modified_trip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TripDescriptor>(
            "TripDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TripDescriptor {
    const NAME: &'static str = "TripDescriptor";

    fn is_initialized(&self) -> bool {
        for v in &self.modified_trip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trip_id = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.route_id = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.direction_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.start_time = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.start_date = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.schedule_relationship = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_trip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trip_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.route_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.direction_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.start_time.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.start_date.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.schedule_relationship {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.modified_trip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trip_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.route_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.direction_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.start_date.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.schedule_relationship {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.modified_trip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TripDescriptor {
        TripDescriptor::new()
    }

    fn clear(&mut self) {
        self.trip_id = ::std::option::Option::None;
        self.route_id = ::std::option::Option::None;
        self.direction_id = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.start_date = ::std::option::Option::None;
        self.schedule_relationship = ::std::option::Option::None;
        self.modified_trip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TripDescriptor {
        static instance: TripDescriptor = TripDescriptor {
            trip_id: ::std::option::Option::None,
            route_id: ::std::option::Option::None,
            direction_id: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            start_date: ::std::option::Option::None,
            schedule_relationship: ::std::option::Option::None,
            modified_trip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TripDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TripDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TripDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TripDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TripDescriptor`
pub mod trip_descriptor {
    // @@protoc_insertion_point(message:transit_realtime.TripDescriptor.ModifiedTripSelector)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ModifiedTripSelector {
        // message fields
        // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.ModifiedTripSelector.modifications_id)
        pub modifications_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.ModifiedTripSelector.affected_trip_id)
        pub affected_trip_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.ModifiedTripSelector.start_time)
        pub start_time: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.ModifiedTripSelector.start_date)
        pub start_date: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TripDescriptor.ModifiedTripSelector.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ModifiedTripSelector {
        fn default() -> &'a ModifiedTripSelector {
            <ModifiedTripSelector as ::protobuf::Message>::default_instance()
        }
    }

    impl ModifiedTripSelector {
        pub fn new() -> ModifiedTripSelector {
            ::std::default::Default::default()
        }

        // optional string modifications_id = 1;

        pub fn modifications_id(&self) -> &str {
            match self.modifications_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_modifications_id(&mut self) {
            self.modifications_id = ::std::option::Option::None;
        }

        pub fn has_modifications_id(&self) -> bool {
            self.modifications_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_modifications_id(&mut self, v: ::std::string::String) {
            self.modifications_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_modifications_id(&mut self) -> &mut ::std::string::String {
            if self.modifications_id.is_none() {
                self.modifications_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.modifications_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_modifications_id(&mut self) -> ::std::string::String {
            self.modifications_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string affected_trip_id = 2;

        pub fn affected_trip_id(&self) -> &str {
            match self.affected_trip_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_affected_trip_id(&mut self) {
            self.affected_trip_id = ::std::option::Option::None;
        }

        pub fn has_affected_trip_id(&self) -> bool {
            self.affected_trip_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_affected_trip_id(&mut self, v: ::std::string::String) {
            self.affected_trip_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_affected_trip_id(&mut self) -> &mut ::std::string::String {
            if self.affected_trip_id.is_none() {
                self.affected_trip_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.affected_trip_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_affected_trip_id(&mut self) -> ::std::string::String {
            self.affected_trip_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string start_time = 3;

        pub fn start_time(&self) -> &str {
            match self.start_time.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: ::std::string::String) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_start_time(&mut self) -> &mut ::std::string::String {
            if self.start_time.is_none() {
                self.start_time = ::std::option::Option::Some(::std::string::String::new());
            }
            self.start_time.as_mut().unwrap()
        }

        // Take field
        pub fn take_start_time(&mut self) -> ::std::string::String {
            self.start_time.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string start_date = 4;

        pub fn start_date(&self) -> &str {
            match self.start_date.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_start_date(&mut self) {
            self.start_date = ::std::option::Option::None;
        }

        pub fn has_start_date(&self) -> bool {
            self.start_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_date(&mut self, v: ::std::string::String) {
            self.start_date = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_start_date(&mut self) -> &mut ::std::string::String {
            if self.start_date.is_none() {
                self.start_date = ::std::option::Option::Some(::std::string::String::new());
            }
            self.start_date.as_mut().unwrap()
        }

        // Take field
        pub fn take_start_date(&mut self) -> ::std::string::String {
            self.start_date.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "modifications_id",
                |m: &ModifiedTripSelector| { &m.modifications_id },
                |m: &mut ModifiedTripSelector| { &mut m.modifications_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "affected_trip_id",
                |m: &ModifiedTripSelector| { &m.affected_trip_id },
                |m: &mut ModifiedTripSelector| { &mut m.affected_trip_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_time",
                |m: &ModifiedTripSelector| { &m.start_time },
                |m: &mut ModifiedTripSelector| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_date",
                |m: &ModifiedTripSelector| { &m.start_date },
                |m: &mut ModifiedTripSelector| { &mut m.start_date },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModifiedTripSelector>(
                "TripDescriptor.ModifiedTripSelector",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ModifiedTripSelector {
        const NAME: &'static str = "ModifiedTripSelector";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.modifications_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.affected_trip_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.start_time = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.start_date = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.modifications_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.affected_trip_id.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.start_time.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.start_date.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.modifications_id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.affected_trip_id.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.start_time.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.start_date.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ModifiedTripSelector {
            ModifiedTripSelector::new()
        }

        fn clear(&mut self) {
            self.modifications_id = ::std::option::Option::None;
            self.affected_trip_id = ::std::option::Option::None;
            self.start_time = ::std::option::Option::None;
            self.start_date = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ModifiedTripSelector {
            static instance: ModifiedTripSelector = ModifiedTripSelector {
                modifications_id: ::std::option::Option::None,
                affected_trip_id: ::std::option::Option::None,
                start_time: ::std::option::Option::None,
                start_date: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ModifiedTripSelector {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TripDescriptor.ModifiedTripSelector").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ModifiedTripSelector {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ModifiedTripSelector {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.TripDescriptor.ScheduleRelationship)
    pub enum ScheduleRelationship {
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.SCHEDULED)
        SCHEDULED = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.ADDED)
        ADDED = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.UNSCHEDULED)
        UNSCHEDULED = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.CANCELED)
        CANCELED = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.REPLACEMENT)
        REPLACEMENT = 5,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.DUPLICATED)
        DUPLICATED = 6,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.DELETED)
        DELETED = 7,
    }

    impl ::protobuf::Enum for ScheduleRelationship {
        const NAME: &'static str = "ScheduleRelationship";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ScheduleRelationship> {
            match value {
                0 => ::std::option::Option::Some(ScheduleRelationship::SCHEDULED),
                1 => ::std::option::Option::Some(ScheduleRelationship::ADDED),
                2 => ::std::option::Option::Some(ScheduleRelationship::UNSCHEDULED),
                3 => ::std::option::Option::Some(ScheduleRelationship::CANCELED),
                5 => ::std::option::Option::Some(ScheduleRelationship::REPLACEMENT),
                6 => ::std::option::Option::Some(ScheduleRelationship::DUPLICATED),
                7 => ::std::option::Option::Some(ScheduleRelationship::DELETED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ScheduleRelationship> {
            match str {
                "SCHEDULED" => ::std::option::Option::Some(ScheduleRelationship::SCHEDULED),
                "ADDED" => ::std::option::Option::Some(ScheduleRelationship::ADDED),
                "UNSCHEDULED" => ::std::option::Option::Some(ScheduleRelationship::UNSCHEDULED),
                "CANCELED" => ::std::option::Option::Some(ScheduleRelationship::CANCELED),
                "REPLACEMENT" => ::std::option::Option::Some(ScheduleRelationship::REPLACEMENT),
                "DUPLICATED" => ::std::option::Option::Some(ScheduleRelationship::DUPLICATED),
                "DELETED" => ::std::option::Option::Some(ScheduleRelationship::DELETED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ScheduleRelationship] = &[
            ScheduleRelationship::SCHEDULED,
            ScheduleRelationship::ADDED,
            ScheduleRelationship::UNSCHEDULED,
            ScheduleRelationship::CANCELED,
            ScheduleRelationship::REPLACEMENT,
            ScheduleRelationship::DUPLICATED,
            ScheduleRelationship::DELETED,
        ];
    }

    impl ::protobuf::EnumFull for ScheduleRelationship {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TripDescriptor.ScheduleRelationship").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ScheduleRelationship::SCHEDULED => 0,
                ScheduleRelationship::ADDED => 1,
                ScheduleRelationship::UNSCHEDULED => 2,
                ScheduleRelationship::CANCELED => 3,
                ScheduleRelationship::REPLACEMENT => 4,
                ScheduleRelationship::DUPLICATED => 5,
                ScheduleRelationship::DELETED => 6,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ScheduleRelationship {
        fn default() -> Self {
            ScheduleRelationship::SCHEDULED
        }
    }

    impl ScheduleRelationship {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ScheduleRelationship>("TripDescriptor.ScheduleRelationship")
        }
    }
}

// @@protoc_insertion_point(message:transit_realtime.VehicleDescriptor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VehicleDescriptor {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.VehicleDescriptor.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.VehicleDescriptor.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.VehicleDescriptor.license_plate)
    pub license_plate: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.VehicleDescriptor.wheelchair_accessible)
    pub wheelchair_accessible: ::std::option::Option<::protobuf::EnumOrUnknown<vehicle_descriptor::WheelchairAccessible>>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.VehicleDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VehicleDescriptor {
    fn default() -> &'a VehicleDescriptor {
        <VehicleDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl VehicleDescriptor {
    pub fn new() -> VehicleDescriptor {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 2;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string license_plate = 3;

    pub fn license_plate(&self) -> &str {
        match self.license_plate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_license_plate(&mut self) {
        self.license_plate = ::std::option::Option::None;
    }

    pub fn has_license_plate(&self) -> bool {
        self.license_plate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license_plate(&mut self, v: ::std::string::String) {
        self.license_plate = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license_plate(&mut self) -> &mut ::std::string::String {
        if self.license_plate.is_none() {
            self.license_plate = ::std::option::Option::Some(::std::string::String::new());
        }
        self.license_plate.as_mut().unwrap()
    }

    // Take field
    pub fn take_license_plate(&mut self) -> ::std::string::String {
        self.license_plate.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4;

    pub fn wheelchair_accessible(&self) -> vehicle_descriptor::WheelchairAccessible {
        match self.wheelchair_accessible {
            Some(e) => e.enum_value_or(vehicle_descriptor::WheelchairAccessible::NO_VALUE),
            None => vehicle_descriptor::WheelchairAccessible::NO_VALUE,
        }
    }

    pub fn clear_wheelchair_accessible(&mut self) {
        self.wheelchair_accessible = ::std::option::Option::None;
    }

    pub fn has_wheelchair_accessible(&self) -> bool {
        self.wheelchair_accessible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wheelchair_accessible(&mut self, v: vehicle_descriptor::WheelchairAccessible) {
        self.wheelchair_accessible = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &VehicleDescriptor| { &m.id },
            |m: &mut VehicleDescriptor| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &VehicleDescriptor| { &m.label },
            |m: &mut VehicleDescriptor| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "license_plate",
            |m: &VehicleDescriptor| { &m.license_plate },
            |m: &mut VehicleDescriptor| { &mut m.license_plate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wheelchair_accessible",
            |m: &VehicleDescriptor| { &m.wheelchair_accessible },
            |m: &mut VehicleDescriptor| { &mut m.wheelchair_accessible },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VehicleDescriptor>(
            "VehicleDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VehicleDescriptor {
    const NAME: &'static str = "VehicleDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.license_plate = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.wheelchair_accessible = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.license_plate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.wheelchair_accessible {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.license_plate.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.wheelchair_accessible {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VehicleDescriptor {
        VehicleDescriptor::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.license_plate = ::std::option::Option::None;
        self.wheelchair_accessible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VehicleDescriptor {
        static instance: VehicleDescriptor = VehicleDescriptor {
            id: ::std::option::Option::None,
            label: ::std::option::Option::None,
            license_plate: ::std::option::Option::None,
            wheelchair_accessible: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VehicleDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VehicleDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VehicleDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VehicleDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VehicleDescriptor`
pub mod vehicle_descriptor {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.VehicleDescriptor.WheelchairAccessible)
    pub enum WheelchairAccessible {
        // @@protoc_insertion_point(enum_value:transit_realtime.VehicleDescriptor.WheelchairAccessible.NO_VALUE)
        NO_VALUE = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehicleDescriptor.WheelchairAccessible.UNKNOWN)
        UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehicleDescriptor.WheelchairAccessible.WHEELCHAIR_ACCESSIBLE)
        WHEELCHAIR_ACCESSIBLE = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehicleDescriptor.WheelchairAccessible.WHEELCHAIR_INACCESSIBLE)
        WHEELCHAIR_INACCESSIBLE = 3,
    }

    impl ::protobuf::Enum for WheelchairAccessible {
        const NAME: &'static str = "WheelchairAccessible";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WheelchairAccessible> {
            match value {
                0 => ::std::option::Option::Some(WheelchairAccessible::NO_VALUE),
                1 => ::std::option::Option::Some(WheelchairAccessible::UNKNOWN),
                2 => ::std::option::Option::Some(WheelchairAccessible::WHEELCHAIR_ACCESSIBLE),
                3 => ::std::option::Option::Some(WheelchairAccessible::WHEELCHAIR_INACCESSIBLE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<WheelchairAccessible> {
            match str {
                "NO_VALUE" => ::std::option::Option::Some(WheelchairAccessible::NO_VALUE),
                "UNKNOWN" => ::std::option::Option::Some(WheelchairAccessible::UNKNOWN),
                "WHEELCHAIR_ACCESSIBLE" => ::std::option::Option::Some(WheelchairAccessible::WHEELCHAIR_ACCESSIBLE),
                "WHEELCHAIR_INACCESSIBLE" => ::std::option::Option::Some(WheelchairAccessible::WHEELCHAIR_INACCESSIBLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WheelchairAccessible] = &[
            WheelchairAccessible::NO_VALUE,
            WheelchairAccessible::UNKNOWN,
            WheelchairAccessible::WHEELCHAIR_ACCESSIBLE,
            WheelchairAccessible::WHEELCHAIR_INACCESSIBLE,
        ];
    }

    impl ::protobuf::EnumFull for WheelchairAccessible {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VehicleDescriptor.WheelchairAccessible").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WheelchairAccessible {
        fn default() -> Self {
            WheelchairAccessible::NO_VALUE
        }
    }

    impl WheelchairAccessible {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WheelchairAccessible>("VehicleDescriptor.WheelchairAccessible")
        }
    }
}

// @@protoc_insertion_point(message:transit_realtime.EntitySelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EntitySelector {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.agency_id)
    pub agency_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.route_id)
    pub route_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.route_type)
    pub route_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.trip)
    pub trip: ::protobuf::MessageField<TripDescriptor>,
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.stop_id)
    pub stop_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.direction_id)
    pub direction_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.EntitySelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EntitySelector {
    fn default() -> &'a EntitySelector {
        <EntitySelector as ::protobuf::Message>::default_instance()
    }
}

impl EntitySelector {
    pub fn new() -> EntitySelector {
        ::std::default::Default::default()
    }

    // optional string agency_id = 1;

    pub fn agency_id(&self) -> &str {
        match self.agency_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_agency_id(&mut self) {
        self.agency_id = ::std::option::Option::None;
    }

    pub fn has_agency_id(&self) -> bool {
        self.agency_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agency_id(&mut self, v: ::std::string::String) {
        self.agency_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agency_id(&mut self) -> &mut ::std::string::String {
        if self.agency_id.is_none() {
            self.agency_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.agency_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agency_id(&mut self) -> ::std::string::String {
        self.agency_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string route_id = 2;

    pub fn route_id(&self) -> &str {
        match self.route_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_route_id(&mut self) {
        self.route_id = ::std::option::Option::None;
    }

    pub fn has_route_id(&self) -> bool {
        self.route_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_id(&mut self, v: ::std::string::String) {
        self.route_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_id(&mut self) -> &mut ::std::string::String {
        if self.route_id.is_none() {
            self.route_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.route_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_id(&mut self) -> ::std::string::String {
        self.route_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 route_type = 3;

    pub fn route_type(&self) -> i32 {
        self.route_type.unwrap_or(0)
    }

    pub fn clear_route_type(&mut self) {
        self.route_type = ::std::option::Option::None;
    }

    pub fn has_route_type(&self) -> bool {
        self.route_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_type(&mut self, v: i32) {
        self.route_type = ::std::option::Option::Some(v);
    }

    // optional string stop_id = 5;

    pub fn stop_id(&self) -> &str {
        match self.stop_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stop_id(&mut self) {
        self.stop_id = ::std::option::Option::None;
    }

    pub fn has_stop_id(&self) -> bool {
        self.stop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_id(&mut self, v: ::std::string::String) {
        self.stop_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop_id(&mut self) -> &mut ::std::string::String {
        if self.stop_id.is_none() {
            self.stop_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stop_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stop_id(&mut self) -> ::std::string::String {
        self.stop_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 direction_id = 6;

    pub fn direction_id(&self) -> u32 {
        self.direction_id.unwrap_or(0)
    }

    pub fn clear_direction_id(&mut self) {
        self.direction_id = ::std::option::Option::None;
    }

    pub fn has_direction_id(&self) -> bool {
        self.direction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction_id(&mut self, v: u32) {
        self.direction_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "agency_id",
            |m: &EntitySelector| { &m.agency_id },
            |m: &mut EntitySelector| { &mut m.agency_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "route_id",
            |m: &EntitySelector| { &m.route_id },
            |m: &mut EntitySelector| { &mut m.route_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "route_type",
            |m: &EntitySelector| { &m.route_type },
            |m: &mut EntitySelector| { &mut m.route_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TripDescriptor>(
            "trip",
            |m: &EntitySelector| { &m.trip },
            |m: &mut EntitySelector| { &mut m.trip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_id",
            |m: &EntitySelector| { &m.stop_id },
            |m: &mut EntitySelector| { &mut m.stop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "direction_id",
            |m: &EntitySelector| { &m.direction_id },
            |m: &mut EntitySelector| { &mut m.direction_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntitySelector>(
            "EntitySelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EntitySelector {
    const NAME: &'static str = "EntitySelector";

    fn is_initialized(&self) -> bool {
        for v in &self.trip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.agency_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.route_id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.route_type = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip)?;
                },
                42 => {
                    self.stop_id = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.direction_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.agency_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.route_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.route_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.trip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stop_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.direction_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.agency_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.route_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.route_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.trip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.stop_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.direction_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EntitySelector {
        EntitySelector::new()
    }

    fn clear(&mut self) {
        self.agency_id = ::std::option::Option::None;
        self.route_id = ::std::option::Option::None;
        self.route_type = ::std::option::Option::None;
        self.trip.clear();
        self.stop_id = ::std::option::Option::None;
        self.direction_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EntitySelector {
        static instance: EntitySelector = EntitySelector {
            agency_id: ::std::option::Option::None,
            route_id: ::std::option::Option::None,
            route_type: ::std::option::Option::None,
            trip: ::protobuf::MessageField::none(),
            stop_id: ::std::option::Option::None,
            direction_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EntitySelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EntitySelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EntitySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntitySelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:transit_realtime.TranslatedString)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TranslatedString {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.TranslatedString.translation)
    pub translation: ::std::vec::Vec<translated_string::Translation>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TranslatedString.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TranslatedString {
    fn default() -> &'a TranslatedString {
        <TranslatedString as ::protobuf::Message>::default_instance()
    }
}

impl TranslatedString {
    pub fn new() -> TranslatedString {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "translation",
            |m: &TranslatedString| { &m.translation },
            |m: &mut TranslatedString| { &mut m.translation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TranslatedString>(
            "TranslatedString",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TranslatedString {
    const NAME: &'static str = "TranslatedString";

    fn is_initialized(&self) -> bool {
        for v in &self.translation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.translation.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.translation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.translation {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TranslatedString {
        TranslatedString::new()
    }

    fn clear(&mut self) {
        self.translation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TranslatedString {
        static instance: TranslatedString = TranslatedString {
            translation: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TranslatedString {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TranslatedString").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TranslatedString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslatedString {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TranslatedString`
pub mod translated_string {
    // @@protoc_insertion_point(message:transit_realtime.TranslatedString.Translation)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Translation {
        // message fields
        // @@protoc_insertion_point(field:transit_realtime.TranslatedString.Translation.text)
        pub text: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TranslatedString.Translation.language)
        pub language: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TranslatedString.Translation.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Translation {
        fn default() -> &'a Translation {
            <Translation as ::protobuf::Message>::default_instance()
        }
    }

    impl Translation {
        pub fn new() -> Translation {
            ::std::default::Default::default()
        }

        // required string text = 1;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string language = 2;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "text",
                |m: &Translation| { &m.text },
                |m: &mut Translation| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language",
                |m: &Translation| { &m.language },
                |m: &mut Translation| { &mut m.language },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Translation>(
                "TranslatedString.Translation",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Translation {
        const NAME: &'static str = "Translation";

        fn is_initialized(&self) -> bool {
            if self.text.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.text.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.language.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.text.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.language.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Translation {
            Translation::new()
        }

        fn clear(&mut self) {
            self.text = ::std::option::Option::None;
            self.language = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Translation {
            static instance: Translation = Translation {
                text: ::std::option::Option::None,
                language: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Translation {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TranslatedString.Translation").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Translation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Translation {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:transit_realtime.TranslatedImage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TranslatedImage {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.TranslatedImage.localized_image)
    pub localized_image: ::std::vec::Vec<translated_image::LocalizedImage>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TranslatedImage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TranslatedImage {
    fn default() -> &'a TranslatedImage {
        <TranslatedImage as ::protobuf::Message>::default_instance()
    }
}

impl TranslatedImage {
    pub fn new() -> TranslatedImage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "localized_image",
            |m: &TranslatedImage| { &m.localized_image },
            |m: &mut TranslatedImage| { &mut m.localized_image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TranslatedImage>(
            "TranslatedImage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TranslatedImage {
    const NAME: &'static str = "TranslatedImage";

    fn is_initialized(&self) -> bool {
        for v in &self.localized_image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.localized_image.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.localized_image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.localized_image {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TranslatedImage {
        TranslatedImage::new()
    }

    fn clear(&mut self) {
        self.localized_image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TranslatedImage {
        static instance: TranslatedImage = TranslatedImage {
            localized_image: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TranslatedImage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TranslatedImage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TranslatedImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslatedImage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TranslatedImage`
pub mod translated_image {
    // @@protoc_insertion_point(message:transit_realtime.TranslatedImage.LocalizedImage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LocalizedImage {
        // message fields
        // @@protoc_insertion_point(field:transit_realtime.TranslatedImage.LocalizedImage.url)
        pub url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TranslatedImage.LocalizedImage.media_type)
        pub media_type: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TranslatedImage.LocalizedImage.language)
        pub language: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TranslatedImage.LocalizedImage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LocalizedImage {
        fn default() -> &'a LocalizedImage {
            <LocalizedImage as ::protobuf::Message>::default_instance()
        }
    }

    impl LocalizedImage {
        pub fn new() -> LocalizedImage {
            ::std::default::Default::default()
        }

        // required string url = 1;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required string media_type = 2;

        pub fn media_type(&self) -> &str {
            match self.media_type.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_media_type(&mut self) {
            self.media_type = ::std::option::Option::None;
        }

        pub fn has_media_type(&self) -> bool {
            self.media_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_media_type(&mut self, v: ::std::string::String) {
            self.media_type = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_media_type(&mut self) -> &mut ::std::string::String {
            if self.media_type.is_none() {
                self.media_type = ::std::option::Option::Some(::std::string::String::new());
            }
            self.media_type.as_mut().unwrap()
        }

        // Take field
        pub fn take_media_type(&mut self) -> ::std::string::String {
            self.media_type.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string language = 3;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "url",
                |m: &LocalizedImage| { &m.url },
                |m: &mut LocalizedImage| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "media_type",
                |m: &LocalizedImage| { &m.media_type },
                |m: &mut LocalizedImage| { &mut m.media_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language",
                |m: &LocalizedImage| { &m.language },
                |m: &mut LocalizedImage| { &mut m.language },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocalizedImage>(
                "TranslatedImage.LocalizedImage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LocalizedImage {
        const NAME: &'static str = "LocalizedImage";

        fn is_initialized(&self) -> bool {
            if self.url.is_none() {
                return false;
            }
            if self.media_type.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.media_type = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.media_type.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.language.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.url.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.media_type.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.language.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LocalizedImage {
            LocalizedImage::new()
        }

        fn clear(&mut self) {
            self.url = ::std::option::Option::None;
            self.media_type = ::std::option::Option::None;
            self.language = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LocalizedImage {
            static instance: LocalizedImage = LocalizedImage {
                url: ::std::option::Option::None,
                media_type: ::std::option::Option::None,
                language: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LocalizedImage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TranslatedImage.LocalizedImage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LocalizedImage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LocalizedImage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:transit_realtime.Shape)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Shape {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.Shape.shape_id)
    pub shape_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.Shape.encoded_polyline)
    pub encoded_polyline: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.Shape.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Shape {
    fn default() -> &'a Shape {
        <Shape as ::protobuf::Message>::default_instance()
    }
}

impl Shape {
    pub fn new() -> Shape {
        ::std::default::Default::default()
    }

    // optional string shape_id = 1;

    pub fn shape_id(&self) -> &str {
        match self.shape_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shape_id(&mut self) {
        self.shape_id = ::std::option::Option::None;
    }

    pub fn has_shape_id(&self) -> bool {
        self.shape_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape_id(&mut self, v: ::std::string::String) {
        self.shape_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape_id(&mut self) -> &mut ::std::string::String {
        if self.shape_id.is_none() {
            self.shape_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shape_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape_id(&mut self) -> ::std::string::String {
        self.shape_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string encoded_polyline = 2;

    pub fn encoded_polyline(&self) -> &str {
        match self.encoded_polyline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_encoded_polyline(&mut self) {
        self.encoded_polyline = ::std::option::Option::None;
    }

    pub fn has_encoded_polyline(&self) -> bool {
        self.encoded_polyline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoded_polyline(&mut self, v: ::std::string::String) {
        self.encoded_polyline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoded_polyline(&mut self) -> &mut ::std::string::String {
        if self.encoded_polyline.is_none() {
            self.encoded_polyline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.encoded_polyline.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoded_polyline(&mut self) -> ::std::string::String {
        self.encoded_polyline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shape_id",
            |m: &Shape| { &m.shape_id },
            |m: &mut Shape| { &mut m.shape_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encoded_polyline",
            |m: &Shape| { &m.encoded_polyline },
            |m: &mut Shape| { &mut m.encoded_polyline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Shape>(
            "Shape",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Shape {
    const NAME: &'static str = "Shape";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shape_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.encoded_polyline = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shape_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.encoded_polyline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shape_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.encoded_polyline.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Shape {
        Shape::new()
    }

    fn clear(&mut self) {
        self.shape_id = ::std::option::Option::None;
        self.encoded_polyline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Shape {
        static instance: Shape = Shape {
            shape_id: ::std::option::Option::None,
            encoded_polyline: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Shape {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Shape").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Shape {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Shape {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:transit_realtime.Stop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Stop {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.Stop.stop_id)
    pub stop_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.stop_code)
    pub stop_code: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.stop_name)
    pub stop_name: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.tts_stop_name)
    pub tts_stop_name: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.stop_desc)
    pub stop_desc: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.stop_lat)
    pub stop_lat: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.stop_lon)
    pub stop_lon: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.zone_id)
    pub zone_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.stop_url)
    pub stop_url: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.parent_station)
    pub parent_station: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.stop_timezone)
    pub stop_timezone: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.wheelchair_boarding)
    pub wheelchair_boarding: ::std::option::Option<::protobuf::EnumOrUnknown<stop::WheelchairBoarding>>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.level_id)
    pub level_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.Stop.platform_code)
    pub platform_code: ::protobuf::MessageField<TranslatedString>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.Stop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Stop {
    fn default() -> &'a Stop {
        <Stop as ::protobuf::Message>::default_instance()
    }
}

impl Stop {
    pub fn new() -> Stop {
        ::std::default::Default::default()
    }

    // optional string stop_id = 1;

    pub fn stop_id(&self) -> &str {
        match self.stop_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stop_id(&mut self) {
        self.stop_id = ::std::option::Option::None;
    }

    pub fn has_stop_id(&self) -> bool {
        self.stop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_id(&mut self, v: ::std::string::String) {
        self.stop_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop_id(&mut self) -> &mut ::std::string::String {
        if self.stop_id.is_none() {
            self.stop_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stop_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stop_id(&mut self) -> ::std::string::String {
        self.stop_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float stop_lat = 6;

    pub fn stop_lat(&self) -> f32 {
        self.stop_lat.unwrap_or(0.)
    }

    pub fn clear_stop_lat(&mut self) {
        self.stop_lat = ::std::option::Option::None;
    }

    pub fn has_stop_lat(&self) -> bool {
        self.stop_lat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_lat(&mut self, v: f32) {
        self.stop_lat = ::std::option::Option::Some(v);
    }

    // optional float stop_lon = 7;

    pub fn stop_lon(&self) -> f32 {
        self.stop_lon.unwrap_or(0.)
    }

    pub fn clear_stop_lon(&mut self) {
        self.stop_lon = ::std::option::Option::None;
    }

    pub fn has_stop_lon(&self) -> bool {
        self.stop_lon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_lon(&mut self, v: f32) {
        self.stop_lon = ::std::option::Option::Some(v);
    }

    // optional string zone_id = 8;

    pub fn zone_id(&self) -> &str {
        match self.zone_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_zone_id(&mut self) {
        self.zone_id = ::std::option::Option::None;
    }

    pub fn has_zone_id(&self) -> bool {
        self.zone_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zone_id(&mut self, v: ::std::string::String) {
        self.zone_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone_id(&mut self) -> &mut ::std::string::String {
        if self.zone_id.is_none() {
            self.zone_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.zone_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_zone_id(&mut self) -> ::std::string::String {
        self.zone_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string parent_station = 11;

    pub fn parent_station(&self) -> &str {
        match self.parent_station.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parent_station(&mut self) {
        self.parent_station = ::std::option::Option::None;
    }

    pub fn has_parent_station(&self) -> bool {
        self.parent_station.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_station(&mut self, v: ::std::string::String) {
        self.parent_station = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_station(&mut self) -> &mut ::std::string::String {
        if self.parent_station.is_none() {
            self.parent_station = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parent_station.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_station(&mut self) -> ::std::string::String {
        self.parent_station.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stop_timezone = 12;

    pub fn stop_timezone(&self) -> &str {
        match self.stop_timezone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stop_timezone(&mut self) {
        self.stop_timezone = ::std::option::Option::None;
    }

    pub fn has_stop_timezone(&self) -> bool {
        self.stop_timezone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_timezone(&mut self, v: ::std::string::String) {
        self.stop_timezone = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop_timezone(&mut self) -> &mut ::std::string::String {
        if self.stop_timezone.is_none() {
            self.stop_timezone = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stop_timezone.as_mut().unwrap()
    }

    // Take field
    pub fn take_stop_timezone(&mut self) -> ::std::string::String {
        self.stop_timezone.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13;

    pub fn wheelchair_boarding(&self) -> stop::WheelchairBoarding {
        match self.wheelchair_boarding {
            Some(e) => e.enum_value_or(stop::WheelchairBoarding::UNKNOWN),
            None => stop::WheelchairBoarding::UNKNOWN,
        }
    }

    pub fn clear_wheelchair_boarding(&mut self) {
        self.wheelchair_boarding = ::std::option::Option::None;
    }

    pub fn has_wheelchair_boarding(&self) -> bool {
        self.wheelchair_boarding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wheelchair_boarding(&mut self, v: stop::WheelchairBoarding) {
        self.wheelchair_boarding = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string level_id = 14;

    pub fn level_id(&self) -> &str {
        match self.level_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_level_id(&mut self) {
        self.level_id = ::std::option::Option::None;
    }

    pub fn has_level_id(&self) -> bool {
        self.level_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_id(&mut self, v: ::std::string::String) {
        self.level_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_id(&mut self) -> &mut ::std::string::String {
        if self.level_id.is_none() {
            self.level_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.level_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_level_id(&mut self) -> ::std::string::String {
        self.level_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_id",
            |m: &Stop| { &m.stop_id },
            |m: &mut Stop| { &mut m.stop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "stop_code",
            |m: &Stop| { &m.stop_code },
            |m: &mut Stop| { &mut m.stop_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "stop_name",
            |m: &Stop| { &m.stop_name },
            |m: &mut Stop| { &mut m.stop_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "tts_stop_name",
            |m: &Stop| { &m.tts_stop_name },
            |m: &mut Stop| { &mut m.tts_stop_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "stop_desc",
            |m: &Stop| { &m.stop_desc },
            |m: &mut Stop| { &mut m.stop_desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_lat",
            |m: &Stop| { &m.stop_lat },
            |m: &mut Stop| { &mut m.stop_lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_lon",
            |m: &Stop| { &m.stop_lon },
            |m: &mut Stop| { &mut m.stop_lon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zone_id",
            |m: &Stop| { &m.zone_id },
            |m: &mut Stop| { &mut m.zone_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "stop_url",
            |m: &Stop| { &m.stop_url },
            |m: &mut Stop| { &mut m.stop_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_station",
            |m: &Stop| { &m.parent_station },
            |m: &mut Stop| { &mut m.parent_station },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_timezone",
            |m: &Stop| { &m.stop_timezone },
            |m: &mut Stop| { &mut m.stop_timezone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wheelchair_boarding",
            |m: &Stop| { &m.wheelchair_boarding },
            |m: &mut Stop| { &mut m.wheelchair_boarding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level_id",
            |m: &Stop| { &m.level_id },
            |m: &mut Stop| { &mut m.level_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "platform_code",
            |m: &Stop| { &m.platform_code },
            |m: &mut Stop| { &mut m.platform_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stop>(
            "Stop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Stop {
    const NAME: &'static str = "Stop";

    fn is_initialized(&self) -> bool {
        for v in &self.stop_code {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stop_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tts_stop_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stop_desc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stop_url {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.platform_code {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stop_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stop_code)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stop_name)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tts_stop_name)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stop_desc)?;
                },
                53 => {
                    self.stop_lat = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.stop_lon = ::std::option::Option::Some(is.read_float()?);
                },
                66 => {
                    self.zone_id = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stop_url)?;
                },
                90 => {
                    self.parent_station = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.stop_timezone = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.wheelchair_boarding = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                114 => {
                    self.level_id = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.platform_code)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stop_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.stop_code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stop_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tts_stop_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stop_desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stop_lat {
            my_size += 1 + 4;
        }
        if let Some(v) = self.stop_lon {
            my_size += 1 + 4;
        }
        if let Some(v) = self.zone_id.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.stop_url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.parent_station.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.stop_timezone.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.wheelchair_boarding {
            my_size += ::protobuf::rt::int32_size(13, v.value());
        }
        if let Some(v) = self.level_id.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.platform_code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stop_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.stop_code.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.stop_name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.tts_stop_name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.stop_desc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.stop_lat {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.stop_lon {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.zone_id.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.stop_url.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.parent_station.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.stop_timezone.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.wheelchair_boarding {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.level_id.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.platform_code.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Stop {
        Stop::new()
    }

    fn clear(&mut self) {
        self.stop_id = ::std::option::Option::None;
        self.stop_code.clear();
        self.stop_name.clear();
        self.tts_stop_name.clear();
        self.stop_desc.clear();
        self.stop_lat = ::std::option::Option::None;
        self.stop_lon = ::std::option::Option::None;
        self.zone_id = ::std::option::Option::None;
        self.stop_url.clear();
        self.parent_station = ::std::option::Option::None;
        self.stop_timezone = ::std::option::Option::None;
        self.wheelchair_boarding = ::std::option::Option::None;
        self.level_id = ::std::option::Option::None;
        self.platform_code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Stop {
        static instance: Stop = Stop {
            stop_id: ::std::option::Option::None,
            stop_code: ::protobuf::MessageField::none(),
            stop_name: ::protobuf::MessageField::none(),
            tts_stop_name: ::protobuf::MessageField::none(),
            stop_desc: ::protobuf::MessageField::none(),
            stop_lat: ::std::option::Option::None,
            stop_lon: ::std::option::Option::None,
            zone_id: ::std::option::Option::None,
            stop_url: ::protobuf::MessageField::none(),
            parent_station: ::std::option::Option::None,
            stop_timezone: ::std::option::Option::None,
            wheelchair_boarding: ::std::option::Option::None,
            level_id: ::std::option::Option::None,
            platform_code: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Stop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Stop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Stop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Stop`
pub mod stop {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.Stop.WheelchairBoarding)
    pub enum WheelchairBoarding {
        // @@protoc_insertion_point(enum_value:transit_realtime.Stop.WheelchairBoarding.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.Stop.WheelchairBoarding.AVAILABLE)
        AVAILABLE = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.Stop.WheelchairBoarding.NOT_AVAILABLE)
        NOT_AVAILABLE = 2,
    }

    impl ::protobuf::Enum for WheelchairBoarding {
        const NAME: &'static str = "WheelchairBoarding";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WheelchairBoarding> {
            match value {
                0 => ::std::option::Option::Some(WheelchairBoarding::UNKNOWN),
                1 => ::std::option::Option::Some(WheelchairBoarding::AVAILABLE),
                2 => ::std::option::Option::Some(WheelchairBoarding::NOT_AVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<WheelchairBoarding> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(WheelchairBoarding::UNKNOWN),
                "AVAILABLE" => ::std::option::Option::Some(WheelchairBoarding::AVAILABLE),
                "NOT_AVAILABLE" => ::std::option::Option::Some(WheelchairBoarding::NOT_AVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WheelchairBoarding] = &[
            WheelchairBoarding::UNKNOWN,
            WheelchairBoarding::AVAILABLE,
            WheelchairBoarding::NOT_AVAILABLE,
        ];
    }

    impl ::protobuf::EnumFull for WheelchairBoarding {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Stop.WheelchairBoarding").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WheelchairBoarding {
        fn default() -> Self {
            WheelchairBoarding::UNKNOWN
        }
    }

    impl WheelchairBoarding {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WheelchairBoarding>("Stop.WheelchairBoarding")
        }
    }
}

// @@protoc_insertion_point(message:transit_realtime.TripModifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TripModifications {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.TripModifications.selected_trips)
    pub selected_trips: ::std::vec::Vec<trip_modifications::SelectedTrips>,
    // @@protoc_insertion_point(field:transit_realtime.TripModifications.start_times)
    pub start_times: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.TripModifications.service_dates)
    pub service_dates: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.TripModifications.modifications)
    pub modifications: ::std::vec::Vec<trip_modifications::Modification>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TripModifications.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TripModifications {
    fn default() -> &'a TripModifications {
        <TripModifications as ::protobuf::Message>::default_instance()
    }
}

impl TripModifications {
    pub fn new() -> TripModifications {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selected_trips",
            |m: &TripModifications| { &m.selected_trips },
            |m: &mut TripModifications| { &mut m.selected_trips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "start_times",
            |m: &TripModifications| { &m.start_times },
            |m: &mut TripModifications| { &mut m.start_times },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_dates",
            |m: &TripModifications| { &m.service_dates },
            |m: &mut TripModifications| { &mut m.service_dates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifications",
            |m: &TripModifications| { &m.modifications },
            |m: &mut TripModifications| { &mut m.modifications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TripModifications>(
            "TripModifications",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TripModifications {
    const NAME: &'static str = "TripModifications";

    fn is_initialized(&self) -> bool {
        for v in &self.selected_trips {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selected_trips.push(is.read_message()?);
                },
                18 => {
                    self.start_times.push(is.read_string()?);
                },
                26 => {
                    self.service_dates.push(is.read_string()?);
                },
                34 => {
                    self.modifications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.selected_trips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.start_times {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.service_dates {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.modifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.selected_trips {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.start_times {
            os.write_string(2, &v)?;
        };
        for v in &self.service_dates {
            os.write_string(3, &v)?;
        };
        for v in &self.modifications {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TripModifications {
        TripModifications::new()
    }

    fn clear(&mut self) {
        self.selected_trips.clear();
        self.start_times.clear();
        self.service_dates.clear();
        self.modifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TripModifications {
        static instance: TripModifications = TripModifications {
            selected_trips: ::std::vec::Vec::new(),
            start_times: ::std::vec::Vec::new(),
            service_dates: ::std::vec::Vec::new(),
            modifications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TripModifications {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TripModifications").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TripModifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TripModifications {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TripModifications`
pub mod trip_modifications {
    // @@protoc_insertion_point(message:transit_realtime.TripModifications.Modification)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Modification {
        // message fields
        // @@protoc_insertion_point(field:transit_realtime.TripModifications.Modification.start_stop_selector)
        pub start_stop_selector: ::protobuf::MessageField<super::StopSelector>,
        // @@protoc_insertion_point(field:transit_realtime.TripModifications.Modification.end_stop_selector)
        pub end_stop_selector: ::protobuf::MessageField<super::StopSelector>,
        // @@protoc_insertion_point(field:transit_realtime.TripModifications.Modification.propagated_modification_delay)
        pub propagated_modification_delay: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:transit_realtime.TripModifications.Modification.replacement_stops)
        pub replacement_stops: ::std::vec::Vec<super::ReplacementStop>,
        // @@protoc_insertion_point(field:transit_realtime.TripModifications.Modification.service_alert_id)
        pub service_alert_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripModifications.Modification.last_modified_time)
        pub last_modified_time: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TripModifications.Modification.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Modification {
        fn default() -> &'a Modification {
            <Modification as ::protobuf::Message>::default_instance()
        }
    }

    impl Modification {
        pub fn new() -> Modification {
            ::std::default::Default::default()
        }

        // optional int32 propagated_modification_delay = 3;

        pub fn propagated_modification_delay(&self) -> i32 {
            self.propagated_modification_delay.unwrap_or(0i32)
        }

        pub fn clear_propagated_modification_delay(&mut self) {
            self.propagated_modification_delay = ::std::option::Option::None;
        }

        pub fn has_propagated_modification_delay(&self) -> bool {
            self.propagated_modification_delay.is_some()
        }

        // Param is passed by value, moved
        pub fn set_propagated_modification_delay(&mut self, v: i32) {
            self.propagated_modification_delay = ::std::option::Option::Some(v);
        }

        // optional string service_alert_id = 5;

        pub fn service_alert_id(&self) -> &str {
            match self.service_alert_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_service_alert_id(&mut self) {
            self.service_alert_id = ::std::option::Option::None;
        }

        pub fn has_service_alert_id(&self) -> bool {
            self.service_alert_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_service_alert_id(&mut self, v: ::std::string::String) {
            self.service_alert_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_service_alert_id(&mut self) -> &mut ::std::string::String {
            if self.service_alert_id.is_none() {
                self.service_alert_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.service_alert_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_service_alert_id(&mut self) -> ::std::string::String {
            self.service_alert_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 last_modified_time = 6;

        pub fn last_modified_time(&self) -> u64 {
            self.last_modified_time.unwrap_or(0)
        }

        pub fn clear_last_modified_time(&mut self) {
            self.last_modified_time = ::std::option::Option::None;
        }

        pub fn has_last_modified_time(&self) -> bool {
            self.last_modified_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_modified_time(&mut self, v: u64) {
            self.last_modified_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::StopSelector>(
                "start_stop_selector",
                |m: &Modification| { &m.start_stop_selector },
                |m: &mut Modification| { &mut m.start_stop_selector },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::StopSelector>(
                "end_stop_selector",
                |m: &Modification| { &m.end_stop_selector },
                |m: &mut Modification| { &mut m.end_stop_selector },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "propagated_modification_delay",
                |m: &Modification| { &m.propagated_modification_delay },
                |m: &mut Modification| { &mut m.propagated_modification_delay },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "replacement_stops",
                |m: &Modification| { &m.replacement_stops },
                |m: &mut Modification| { &mut m.replacement_stops },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "service_alert_id",
                |m: &Modification| { &m.service_alert_id },
                |m: &mut Modification| { &mut m.service_alert_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_modified_time",
                |m: &Modification| { &m.last_modified_time },
                |m: &mut Modification| { &mut m.last_modified_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Modification>(
                "TripModifications.Modification",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Modification {
        const NAME: &'static str = "Modification";

        fn is_initialized(&self) -> bool {
            for v in &self.start_stop_selector {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.end_stop_selector {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.replacement_stops {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_stop_selector)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_stop_selector)?;
                    },
                    24 => {
                        self.propagated_modification_delay = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.replacement_stops.push(is.read_message()?);
                    },
                    42 => {
                        self.service_alert_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.last_modified_time = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start_stop_selector.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.end_stop_selector.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.propagated_modification_delay {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            for value in &self.replacement_stops {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.service_alert_id.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.last_modified_time {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.start_stop_selector.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.end_stop_selector.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.propagated_modification_delay {
                os.write_int32(3, v)?;
            }
            for v in &self.replacement_stops {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            if let Some(v) = self.service_alert_id.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.last_modified_time {
                os.write_uint64(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Modification {
            Modification::new()
        }

        fn clear(&mut self) {
            self.start_stop_selector.clear();
            self.end_stop_selector.clear();
            self.propagated_modification_delay = ::std::option::Option::None;
            self.replacement_stops.clear();
            self.service_alert_id = ::std::option::Option::None;
            self.last_modified_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Modification {
            static instance: Modification = Modification {
                start_stop_selector: ::protobuf::MessageField::none(),
                end_stop_selector: ::protobuf::MessageField::none(),
                propagated_modification_delay: ::std::option::Option::None,
                replacement_stops: ::std::vec::Vec::new(),
                service_alert_id: ::std::option::Option::None,
                last_modified_time: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Modification {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TripModifications.Modification").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Modification {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Modification {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:transit_realtime.TripModifications.SelectedTrips)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SelectedTrips {
        // message fields
        // @@protoc_insertion_point(field:transit_realtime.TripModifications.SelectedTrips.trip_ids)
        pub trip_ids: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripModifications.SelectedTrips.shape_id)
        pub shape_id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TripModifications.SelectedTrips.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SelectedTrips {
        fn default() -> &'a SelectedTrips {
            <SelectedTrips as ::protobuf::Message>::default_instance()
        }
    }

    impl SelectedTrips {
        pub fn new() -> SelectedTrips {
            ::std::default::Default::default()
        }

        // optional string shape_id = 2;

        pub fn shape_id(&self) -> &str {
            match self.shape_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_shape_id(&mut self) {
            self.shape_id = ::std::option::Option::None;
        }

        pub fn has_shape_id(&self) -> bool {
            self.shape_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_shape_id(&mut self, v: ::std::string::String) {
            self.shape_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_shape_id(&mut self) -> &mut ::std::string::String {
            if self.shape_id.is_none() {
                self.shape_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.shape_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_shape_id(&mut self) -> ::std::string::String {
            self.shape_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "trip_ids",
                |m: &SelectedTrips| { &m.trip_ids },
                |m: &mut SelectedTrips| { &mut m.trip_ids },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "shape_id",
                |m: &SelectedTrips| { &m.shape_id },
                |m: &mut SelectedTrips| { &mut m.shape_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectedTrips>(
                "TripModifications.SelectedTrips",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SelectedTrips {
        const NAME: &'static str = "SelectedTrips";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.trip_ids.push(is.read_string()?);
                    },
                    18 => {
                        self.shape_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.trip_ids {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            if let Some(v) = self.shape_id.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.trip_ids {
                os.write_string(1, &v)?;
            };
            if let Some(v) = self.shape_id.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SelectedTrips {
            SelectedTrips::new()
        }

        fn clear(&mut self) {
            self.trip_ids.clear();
            self.shape_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SelectedTrips {
            static instance: SelectedTrips = SelectedTrips {
                trip_ids: ::std::vec::Vec::new(),
                shape_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SelectedTrips {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TripModifications.SelectedTrips").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SelectedTrips {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SelectedTrips {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:transit_realtime.StopSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StopSelector {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.StopSelector.stop_sequence)
    pub stop_sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:transit_realtime.StopSelector.stop_id)
    pub stop_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.StopSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StopSelector {
    fn default() -> &'a StopSelector {
        <StopSelector as ::protobuf::Message>::default_instance()
    }
}

impl StopSelector {
    pub fn new() -> StopSelector {
        ::std::default::Default::default()
    }

    // optional uint32 stop_sequence = 1;

    pub fn stop_sequence(&self) -> u32 {
        self.stop_sequence.unwrap_or(0)
    }

    pub fn clear_stop_sequence(&mut self) {
        self.stop_sequence = ::std::option::Option::None;
    }

    pub fn has_stop_sequence(&self) -> bool {
        self.stop_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_sequence(&mut self, v: u32) {
        self.stop_sequence = ::std::option::Option::Some(v);
    }

    // optional string stop_id = 2;

    pub fn stop_id(&self) -> &str {
        match self.stop_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stop_id(&mut self) {
        self.stop_id = ::std::option::Option::None;
    }

    pub fn has_stop_id(&self) -> bool {
        self.stop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_id(&mut self, v: ::std::string::String) {
        self.stop_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop_id(&mut self) -> &mut ::std::string::String {
        if self.stop_id.is_none() {
            self.stop_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stop_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stop_id(&mut self) -> ::std::string::String {
        self.stop_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_sequence",
            |m: &StopSelector| { &m.stop_sequence },
            |m: &mut StopSelector| { &mut m.stop_sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_id",
            |m: &StopSelector| { &m.stop_id },
            |m: &mut StopSelector| { &mut m.stop_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopSelector>(
            "StopSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StopSelector {
    const NAME: &'static str = "StopSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stop_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.stop_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stop_sequence {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.stop_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stop_sequence {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stop_id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StopSelector {
        StopSelector::new()
    }

    fn clear(&mut self) {
        self.stop_sequence = ::std::option::Option::None;
        self.stop_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StopSelector {
        static instance: StopSelector = StopSelector {
            stop_sequence: ::std::option::Option::None,
            stop_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StopSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StopSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StopSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:transit_realtime.ReplacementStop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplacementStop {
    // message fields
    // @@protoc_insertion_point(field:transit_realtime.ReplacementStop.travel_time_to_stop)
    pub travel_time_to_stop: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:transit_realtime.ReplacementStop.stop_id)
    pub stop_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.ReplacementStop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplacementStop {
    fn default() -> &'a ReplacementStop {
        <ReplacementStop as ::protobuf::Message>::default_instance()
    }
}

impl ReplacementStop {
    pub fn new() -> ReplacementStop {
        ::std::default::Default::default()
    }

    // optional int32 travel_time_to_stop = 1;

    pub fn travel_time_to_stop(&self) -> i32 {
        self.travel_time_to_stop.unwrap_or(0)
    }

    pub fn clear_travel_time_to_stop(&mut self) {
        self.travel_time_to_stop = ::std::option::Option::None;
    }

    pub fn has_travel_time_to_stop(&self) -> bool {
        self.travel_time_to_stop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_travel_time_to_stop(&mut self, v: i32) {
        self.travel_time_to_stop = ::std::option::Option::Some(v);
    }

    // optional string stop_id = 2;

    pub fn stop_id(&self) -> &str {
        match self.stop_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stop_id(&mut self) {
        self.stop_id = ::std::option::Option::None;
    }

    pub fn has_stop_id(&self) -> bool {
        self.stop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_id(&mut self, v: ::std::string::String) {
        self.stop_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop_id(&mut self) -> &mut ::std::string::String {
        if self.stop_id.is_none() {
            self.stop_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stop_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stop_id(&mut self) -> ::std::string::String {
        self.stop_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "travel_time_to_stop",
            |m: &ReplacementStop| { &m.travel_time_to_stop },
            |m: &mut ReplacementStop| { &mut m.travel_time_to_stop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_id",
            |m: &ReplacementStop| { &m.stop_id },
            |m: &mut ReplacementStop| { &mut m.stop_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplacementStop>(
            "ReplacementStop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplacementStop {
    const NAME: &'static str = "ReplacementStop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.travel_time_to_stop = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.stop_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.travel_time_to_stop {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.stop_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.travel_time_to_stop {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.stop_id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplacementStop {
        ReplacementStop::new()
    }

    fn clear(&mut self) {
        self.travel_time_to_stop = ::std::option::Option::None;
        self.stop_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplacementStop {
        static instance: ReplacementStop = ReplacementStop {
            travel_time_to_stop: ::std::option::Option::None,
            stop_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplacementStop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplacementStop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplacementStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplacementStop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13gtfs-realtime.proto\x12\x10transit_realtime\"\x89\x01\n\x0bFeedMes\
    sage\x124\n\x06header\x18\x01\x20\x02(\x0b2\x1c.transit_realtime.FeedHea\
    derR\x06header\x124\n\x06entity\x18\x02\x20\x03(\x0b2\x1c.transit_realti\
    me.FeedEntityR\x06entity*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\
    \x90N\"\xaa\x02\n\nFeedHeader\x122\n\x15gtfs_realtime_version\x18\x01\
    \x20\x02(\tR\x13gtfsRealtimeVersion\x12a\n\x0eincrementality\x18\x02\x20\
    \x01(\x0e2+.transit_realtime.FeedHeader.Incrementality:\x0cFULL_DATASETR\
    \x0eincrementality\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x04R\ttimestamp\
    \x12!\n\x0cfeed_version\x18\x04\x20\x01(\tR\x0bfeedVersion\"4\n\x0eIncre\
    mentality\x12\x10\n\x0cFULL_DATASET\x10\0\x12\x10\n\x0cDIFFERENTIAL\x10\
    \x01*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xac\x03\n\nFe\
    edEntity\x12\x0e\n\x02id\x18\x01\x20\x02(\tR\x02id\x12$\n\nis_deleted\
    \x18\x02\x20\x01(\x08:\x05falseR\tisDeleted\x12=\n\x0btrip_update\x18\
    \x03\x20\x01(\x0b2\x1c.transit_realtime.TripUpdateR\ntripUpdate\x12;\n\
    \x07vehicle\x18\x04\x20\x01(\x0b2!.transit_realtime.VehiclePositionR\x07\
    vehicle\x12-\n\x05alert\x18\x05\x20\x01(\x0b2\x17.transit_realtime.Alert\
    R\x05alert\x12-\n\x05shape\x18\x06\x20\x01(\x0b2\x17.transit_realtime.Sh\
    apeR\x05shape\x12*\n\x04stop\x18\x07\x20\x01(\x0b2\x16.transit_realtime.\
    StopR\x04stop\x12R\n\x12trip_modifications\x18\x08\x20\x01(\x0b2#.transi\
    t_realtime.TripModificationsR\x11tripModifications*\x06\x08\xe8\x07\x10\
    \xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xed\n\n\nTripUpdate\x124\n\x04trip\x18\
    \x01\x20\x02(\x0b2\x20.transit_realtime.TripDescriptorR\x04trip\x12=\n\
    \x07vehicle\x18\x03\x20\x01(\x0b2#.transit_realtime.VehicleDescriptorR\
    \x07vehicle\x12U\n\x10stop_time_update\x18\x02\x20\x03(\x0b2+.transit_re\
    altime.TripUpdate.StopTimeUpdateR\x0estopTimeUpdate\x12\x1c\n\ttimestamp\
    \x18\x04\x20\x01(\x04R\ttimestamp\x12\x14\n\x05delay\x18\x05\x20\x01(\
    \x05R\x05delay\x12T\n\x0ftrip_properties\x18\x06\x20\x01(\x0b2+.transit_\
    realtime.TripUpdate.TripPropertiesR\x0etripProperties\x1ak\n\rStopTimeEv\
    ent\x12\x14\n\x05delay\x18\x01\x20\x01(\x05R\x05delay\x12\x12\n\x04time\
    \x18\x02\x20\x01(\x03R\x04time\x12\x20\n\x0buncertainty\x18\x03\x20\x01(\
    \x05R\x0buncertainty*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\
    \x1a\xf6\x05\n\x0eStopTimeUpdate\x12#\n\rstop_sequence\x18\x01\x20\x01(\
    \rR\x0cstopSequence\x12\x17\n\x07stop_id\x18\x04\x20\x01(\tR\x06stopId\
    \x12D\n\x07arrival\x18\x02\x20\x01(\x0b2*.transit_realtime.TripUpdate.St\
    opTimeEventR\x07arrival\x12H\n\tdeparture\x18\x03\x20\x01(\x0b2*.transit\
    _realtime.TripUpdate.StopTimeEventR\tdeparture\x12o\n\x1adeparture_occup\
    ancy_status\x18\x07\x20\x01(\x0e21.transit_realtime.VehiclePosition.Occu\
    pancyStatusR\x18departureOccupancyStatus\x12\x80\x01\n\x15schedule_relat\
    ionship\x18\x05\x20\x01(\x0e2@.transit_realtime.TripUpdate.StopTimeUpdat\
    e.ScheduleRelationship:\tSCHEDULEDR\x14scheduleRelationship\x12p\n\x14st\
    op_time_properties\x18\x06\x20\x01(\x0b2>.transit_realtime.TripUpdate.St\
    opTimeUpdate.StopTimePropertiesR\x12stopTimeProperties\x1aN\n\x12StopTim\
    eProperties\x12(\n\x10assigned_stop_id\x18\x01\x20\x01(\tR\x0eassignedSt\
    opId*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"P\n\x14Schedul\
    eRelationship\x12\r\n\tSCHEDULED\x10\0\x12\x0b\n\x07SKIPPED\x10\x01\x12\
    \x0b\n\x07NO_DATA\x10\x02\x12\x0f\n\x0bUNSCHEDULED\x10\x03*\x06\x08\xe8\
    \x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\x1a\x92\x01\n\x0eTripProperties\
    \x12\x17\n\x07trip_id\x18\x01\x20\x01(\tR\x06tripId\x12\x1d\n\nstart_dat\
    e\x18\x02\x20\x01(\tR\tstartDate\x12\x1d\n\nstart_time\x18\x03\x20\x01(\
    \tR\tstartTime\x12\x19\n\x08shape_id\x18\x04\x20\x01(\tR\x07shapeId*\x06\
    \x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N*\x06\x08\xe8\x07\x10\xd0\
    \x0f*\x06\x08\xa8F\x10\x90N\"\xbf\x0b\n\x0fVehiclePosition\x124\n\x04tri\
    p\x18\x01\x20\x01(\x0b2\x20.transit_realtime.TripDescriptorR\x04trip\x12\
    =\n\x07vehicle\x18\x08\x20\x01(\x0b2#.transit_realtime.VehicleDescriptor\
    R\x07vehicle\x126\n\x08position\x18\x02\x20\x01(\x0b2\x1a.transit_realti\
    me.PositionR\x08position\x122\n\x15current_stop_sequence\x18\x03\x20\x01\
    (\rR\x13currentStopSequence\x12\x17\n\x07stop_id\x18\x07\x20\x01(\tR\x06\
    stopId\x12i\n\x0ecurrent_status\x18\x04\x20\x01(\x0e23.transit_realtime.\
    VehiclePosition.VehicleStopStatus:\rIN_TRANSIT_TOR\rcurrentStatus\x12\
    \x1c\n\ttimestamp\x18\x05\x20\x01(\x04R\ttimestamp\x12\\\n\x10congestion\
    _level\x18\x06\x20\x01(\x0e21.transit_realtime.VehiclePosition.Congestio\
    nLevelR\x0fcongestionLevel\x12\\\n\x10occupancy_status\x18\t\x20\x01(\
    \x0e21.transit_realtime.VehiclePosition.OccupancyStatusR\x0foccupancySta\
    tus\x121\n\x14occupancy_percentage\x18\n\x20\x01(\rR\x13occupancyPercent\
    age\x12g\n\x16multi_carriage_details\x18\x0b\x20\x03(\x0b21.transit_real\
    time.VehiclePosition.CarriageDetailsR\x14multiCarriageDetails\x1a\x9c\
    \x02\n\x0fCarriageDetails\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12o\n\x10occupancy_status\
    \x18\x03\x20\x01(\x0e21.transit_realtime.VehiclePosition.OccupancyStatus\
    :\x11NO_DATA_AVAILABLER\x0foccupancyStatus\x125\n\x14occupancy_percentag\
    e\x18\x04\x20\x01(\x05:\x02-1R\x13occupancyPercentage\x12+\n\x11carriage\
    _sequence\x18\x05\x20\x01(\rR\x10carriageSequence*\x06\x08\xe8\x07\x10\
    \xd0\x0f*\x06\x08\xa8F\x10\x90N\"G\n\x11VehicleStopStatus\x12\x0f\n\x0bI\
    NCOMING_AT\x10\0\x12\x0e\n\nSTOPPED_AT\x10\x01\x12\x11\n\rIN_TRANSIT_TO\
    \x10\x02\"}\n\x0fCongestionLevel\x12\x1c\n\x18UNKNOWN_CONGESTION_LEVEL\
    \x10\0\x12\x14\n\x10RUNNING_SMOOTHLY\x10\x01\x12\x0f\n\x0bSTOP_AND_GO\
    \x10\x02\x12\x0e\n\nCONGESTION\x10\x03\x12\x15\n\x11SEVERE_CONGESTION\
    \x10\x04\"\xd9\x01\n\x0fOccupancyStatus\x12\t\n\x05EMPTY\x10\0\x12\x18\n\
    \x14MANY_SEATS_AVAILABLE\x10\x01\x12\x17\n\x13FEW_SEATS_AVAILABLE\x10\
    \x02\x12\x16\n\x12STANDING_ROOM_ONLY\x10\x03\x12\x1e\n\x1aCRUSHED_STANDI\
    NG_ROOM_ONLY\x10\x04\x12\x08\n\x04FULL\x10\x05\x12\x1c\n\x18NOT_ACCEPTIN\
    G_PASSENGERS\x10\x06\x12\x15\n\x11NO_DATA_AVAILABLE\x10\x07\x12\x11\n\rN\
    OT_BOARDABLE\x10\x08*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\
    \"\xa4\x0c\n\x05Alert\x12@\n\ractive_period\x18\x01\x20\x03(\x0b2\x1b.tr\
    ansit_realtime.TimeRangeR\x0cactivePeriod\x12I\n\x0finformed_entity\x18\
    \x05\x20\x03(\x0b2\x20.transit_realtime.EntitySelectorR\x0einformedEntit\
    y\x12B\n\x05cause\x18\x06\x20\x01(\x0e2\x1d.transit_realtime.Alert.Cause\
    :\rUNKNOWN_CAUSER\x05cause\x12F\n\x06effect\x18\x07\x20\x01(\x0e2\x1e.tr\
    ansit_realtime.Alert.Effect:\x0eUNKNOWN_EFFECTR\x06effect\x124\n\x03url\
    \x18\x08\x20\x01(\x0b2\".transit_realtime.TranslatedStringR\x03url\x12C\
    \n\x0bheader_text\x18\n\x20\x01(\x0b2\".transit_realtime.TranslatedStrin\
    gR\nheaderText\x12M\n\x10description_text\x18\x0b\x20\x01(\x0b2\".transi\
    t_realtime.TranslatedStringR\x0fdescriptionText\x12J\n\x0ftts_header_tex\
    t\x18\x0c\x20\x01(\x0b2\".transit_realtime.TranslatedStringR\rttsHeaderT\
    ext\x12T\n\x14tts_description_text\x18\r\x20\x01(\x0b2\".transit_realtim\
    e.TranslatedStringR\x12ttsDescriptionText\x12^\n\x0eseverity_level\x18\
    \x0e\x20\x01(\x0e2%.transit_realtime.Alert.SeverityLevel:\x10UNKNOWN_SEV\
    ERITYR\rseverityLevel\x127\n\x05image\x18\x0f\x20\x01(\x0b2!.transit_rea\
    ltime.TranslatedImageR\x05image\x12X\n\x16image_alternative_text\x18\x10\
    \x20\x01(\x0b2\".transit_realtime.TranslatedStringR\x14imageAlternativeT\
    ext\x12E\n\x0ccause_detail\x18\x11\x20\x01(\x0b2\".transit_realtime.Tran\
    slatedStringR\x0bcauseDetail\x12G\n\reffect_detail\x18\x12\x20\x01(\x0b2\
    \".transit_realtime.TranslatedStringR\x0ceffectDetail\"\xd8\x01\n\x05Cau\
    se\x12\x11\n\rUNKNOWN_CAUSE\x10\x01\x12\x0f\n\x0bOTHER_CAUSE\x10\x02\x12\
    \x15\n\x11TECHNICAL_PROBLEM\x10\x03\x12\n\n\x06STRIKE\x10\x04\x12\x11\n\
    \rDEMONSTRATION\x10\x05\x12\x0c\n\x08ACCIDENT\x10\x06\x12\x0b\n\x07HOLID\
    AY\x10\x07\x12\x0b\n\x07WEATHER\x10\x08\x12\x0f\n\x0bMAINTENANCE\x10\t\
    \x12\x10\n\x0cCONSTRUCTION\x10\n\x12\x13\n\x0fPOLICE_ACTIVITY\x10\x0b\
    \x12\x15\n\x11MEDICAL_EMERGENCY\x10\x0c\"\xdd\x01\n\x06Effect\x12\x0e\n\
    \nNO_SERVICE\x10\x01\x12\x13\n\x0fREDUCED_SERVICE\x10\x02\x12\x16\n\x12S\
    IGNIFICANT_DELAYS\x10\x03\x12\n\n\x06DETOUR\x10\x04\x12\x16\n\x12ADDITIO\
    NAL_SERVICE\x10\x05\x12\x14\n\x10MODIFIED_SERVICE\x10\x06\x12\x10\n\x0cO\
    THER_EFFECT\x10\x07\x12\x12\n\x0eUNKNOWN_EFFECT\x10\x08\x12\x0e\n\nSTOP_\
    MOVED\x10\t\x12\r\n\tNO_EFFECT\x10\n\x12\x17\n\x13ACCESSIBILITY_ISSUE\
    \x10\x0b\"H\n\rSeverityLevel\x12\x14\n\x10UNKNOWN_SEVERITY\x10\x01\x12\
    \x08\n\x04INFO\x10\x02\x12\x0b\n\x07WARNING\x10\x03\x12\n\n\x06SEVERE\
    \x10\x04*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"C\n\tTimeR\
    ange\x12\x14\n\x05start\x18\x01\x20\x01(\x04R\x05start\x12\x10\n\x03end\
    \x18\x02\x20\x01(\x04R\x03end*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\
    \x10\x90N\"\xa0\x01\n\x08Position\x12\x1a\n\x08latitude\x18\x01\x20\x02(\
    \x02R\x08latitude\x12\x1c\n\tlongitude\x18\x02\x20\x02(\x02R\tlongitude\
    \x12\x18\n\x07bearing\x18\x03\x20\x01(\x02R\x07bearing\x12\x1a\n\x08odom\
    eter\x18\x04\x20\x01(\x01R\x08odometer\x12\x14\n\x05speed\x18\x05\x20\
    \x01(\x02R\x05speed*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\
    \"\xbd\x05\n\x0eTripDescriptor\x12\x17\n\x07trip_id\x18\x01\x20\x01(\tR\
    \x06tripId\x12\x19\n\x08route_id\x18\x05\x20\x01(\tR\x07routeId\x12!\n\
    \x0cdirection_id\x18\x06\x20\x01(\rR\x0bdirectionId\x12\x1d\n\nstart_tim\
    e\x18\x02\x20\x01(\tR\tstartTime\x12\x1d\n\nstart_date\x18\x03\x20\x01(\
    \tR\tstartDate\x12j\n\x15schedule_relationship\x18\x04\x20\x01(\x0e25.tr\
    ansit_realtime.TripDescriptor.ScheduleRelationshipR\x14scheduleRelations\
    hip\x12Z\n\rmodified_trip\x18\x07\x20\x01(\x0b25.transit_realtime.TripDe\
    scriptor.ModifiedTripSelectorR\x0cmodifiedTrip\x1a\xb9\x01\n\x14Modified\
    TripSelector\x12)\n\x10modifications_id\x18\x01\x20\x01(\tR\x0fmodificat\
    ionsId\x12(\n\x10affected_trip_id\x18\x02\x20\x01(\tR\x0eaffectedTripId\
    \x12\x1d\n\nstart_time\x18\x03\x20\x01(\tR\tstartTime\x12\x1d\n\nstart_d\
    ate\x18\x04\x20\x01(\tR\tstartDate*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\
    \xa8F\x10\x90N\"\x81\x01\n\x14ScheduleRelationship\x12\r\n\tSCHEDULED\
    \x10\0\x12\t\n\x05ADDED\x10\x01\x12\x0f\n\x0bUNSCHEDULED\x10\x02\x12\x0c\
    \n\x08CANCELED\x10\x03\x12\x13\n\x0bREPLACEMENT\x10\x05\x1a\x02\x08\x01\
    \x12\x0e\n\nDUPLICATED\x10\x06\x12\x0b\n\x07DELETED\x10\x07*\x06\x08\xe8\
    \x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xd2\x02\n\x11VehicleDescriptor\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05label\x18\x02\
    \x20\x01(\tR\x05label\x12#\n\rlicense_plate\x18\x03\x20\x01(\tR\x0clicen\
    sePlate\x12w\n\x15wheelchair_accessible\x18\x04\x20\x01(\x0e28.transit_r\
    ealtime.VehicleDescriptor.WheelchairAccessible:\x08NO_VALUER\x14wheelcha\
    irAccessible\"i\n\x14WheelchairAccessible\x12\x0c\n\x08NO_VALUE\x10\0\
    \x12\x0b\n\x07UNKNOWN\x10\x01\x12\x19\n\x15WHEELCHAIR_ACCESSIBLE\x10\x02\
    \x12\x1b\n\x17WHEELCHAIR_INACCESSIBLE\x10\x03*\x06\x08\xe8\x07\x10\xd0\
    \x0f*\x06\x08\xa8F\x10\x90N\"\xe9\x01\n\x0eEntitySelector\x12\x1b\n\tage\
    ncy_id\x18\x01\x20\x01(\tR\x08agencyId\x12\x19\n\x08route_id\x18\x02\x20\
    \x01(\tR\x07routeId\x12\x1d\n\nroute_type\x18\x03\x20\x01(\x05R\trouteTy\
    pe\x124\n\x04trip\x18\x04\x20\x01(\x0b2\x20.transit_realtime.TripDescrip\
    torR\x04trip\x12\x17\n\x07stop_id\x18\x05\x20\x01(\tR\x06stopId\x12!\n\
    \x0cdirection_id\x18\x06\x20\x01(\rR\x0bdirectionId*\x06\x08\xe8\x07\x10\
    \xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xc3\x01\n\x10TranslatedString\x12P\n\
    \x0btranslation\x18\x01\x20\x03(\x0b2..transit_realtime.TranslatedString\
    .TranslationR\x0btranslation\x1aM\n\x0bTranslation\x12\x12\n\x04text\x18\
    \x01\x20\x02(\tR\x04text\x12\x1a\n\x08language\x18\x02\x20\x01(\tR\x08la\
    nguage*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N*\x06\x08\xe8\
    \x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xeb\x01\n\x0fTranslatedImage\
    \x12Y\n\x0flocalized_image\x18\x01\x20\x03(\x0b20.transit_realtime.Trans\
    latedImage.LocalizedImageR\x0elocalizedImage\x1am\n\x0eLocalizedImage\
    \x12\x10\n\x03url\x18\x01\x20\x02(\tR\x03url\x12\x1d\n\nmedia_type\x18\
    \x02\x20\x02(\tR\tmediaType\x12\x1a\n\x08language\x18\x03\x20\x01(\tR\
    \x08language*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N*\x06\
    \x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"]\n\x05Shape\x12\x19\n\
    \x08shape_id\x18\x01\x20\x01(\tR\x07shapeId\x12)\n\x10encoded_polyline\
    \x18\x02\x20\x01(\tR\x0fencodedPolyline*\x06\x08\xe8\x07\x10\xd0\x0f*\
    \x06\x08\xa8F\x10\x90N\"\xa2\x06\n\x04Stop\x12\x17\n\x07stop_id\x18\x01\
    \x20\x01(\tR\x06stopId\x12?\n\tstop_code\x18\x02\x20\x01(\x0b2\".transit\
    _realtime.TranslatedStringR\x08stopCode\x12?\n\tstop_name\x18\x03\x20\
    \x01(\x0b2\".transit_realtime.TranslatedStringR\x08stopName\x12F\n\rtts_\
    stop_name\x18\x04\x20\x01(\x0b2\".transit_realtime.TranslatedStringR\x0b\
    ttsStopName\x12?\n\tstop_desc\x18\x05\x20\x01(\x0b2\".transit_realtime.T\
    ranslatedStringR\x08stopDesc\x12\x19\n\x08stop_lat\x18\x06\x20\x01(\x02R\
    \x07stopLat\x12\x19\n\x08stop_lon\x18\x07\x20\x01(\x02R\x07stopLon\x12\
    \x17\n\x07zone_id\x18\x08\x20\x01(\tR\x06zoneId\x12=\n\x08stop_url\x18\t\
    \x20\x01(\x0b2\".transit_realtime.TranslatedStringR\x07stopUrl\x12%\n\
    \x0eparent_station\x18\x0b\x20\x01(\tR\rparentStation\x12#\n\rstop_timez\
    one\x18\x0c\x20\x01(\tR\x0cstopTimezone\x12c\n\x13wheelchair_boarding\
    \x18\r\x20\x01(\x0e2).transit_realtime.Stop.WheelchairBoarding:\x07UNKNO\
    WNR\x12wheelchairBoarding\x12\x19\n\x08level_id\x18\x0e\x20\x01(\tR\x07l\
    evelId\x12G\n\rplatform_code\x18\x0f\x20\x01(\x0b2\".transit_realtime.Tr\
    anslatedStringR\x0cplatformCode\"C\n\x12WheelchairBoarding\x12\x0b\n\x07\
    UNKNOWN\x10\0\x12\r\n\tAVAILABLE\x10\x01\x12\x11\n\rNOT_AVAILABLE\x10\
    \x02*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\x9e\x06\n\x11\
    TripModifications\x12X\n\x0eselected_trips\x18\x01\x20\x03(\x0b21.transi\
    t_realtime.TripModifications.SelectedTripsR\rselectedTrips\x12\x1f\n\x0b\
    start_times\x18\x02\x20\x03(\tR\nstartTimes\x12#\n\rservice_dates\x18\
    \x03\x20\x03(\tR\x0cserviceDates\x12V\n\rmodifications\x18\x04\x20\x03(\
    \x0b20.transit_realtime.TripModifications.ModificationR\rmodifications\
    \x1a\xa9\x03\n\x0cModification\x12N\n\x13start_stop_selector\x18\x01\x20\
    \x01(\x0b2\x1e.transit_realtime.StopSelectorR\x11startStopSelector\x12J\
    \n\x11end_stop_selector\x18\x02\x20\x01(\x0b2\x1e.transit_realtime.StopS\
    electorR\x0fendStopSelector\x12E\n\x1dpropagated_modification_delay\x18\
    \x03\x20\x01(\x05:\x010R\x1bpropagatedModificationDelay\x12N\n\x11replac\
    ement_stops\x18\x04\x20\x03(\x0b2!.transit_realtime.ReplacementStopR\x10\
    replacementStops\x12(\n\x10service_alert_id\x18\x05\x20\x01(\tR\x0eservi\
    ceAlertId\x12,\n\x12last_modified_time\x18\x06\x20\x01(\x04R\x10lastModi\
    fiedTime*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\x1aU\n\rSel\
    ectedTrips\x12\x19\n\x08trip_ids\x18\x01\x20\x03(\tR\x07tripIds\x12\x19\
    \n\x08shape_id\x18\x02\x20\x01(\tR\x07shapeId*\x06\x08\xe8\x07\x10\xd0\
    \x0f*\x06\x08\xa8F\x10\x90N*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\
    \x10\x90N\"\\\n\x0cStopSelector\x12#\n\rstop_sequence\x18\x01\x20\x01(\r\
    R\x0cstopSequence\x12\x17\n\x07stop_id\x18\x02\x20\x01(\tR\x06stopId*\
    \x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"i\n\x0fReplacementS\
    top\x12-\n\x13travel_time_to_stop\x18\x01\x20\x01(\x05R\x10travelTimeToS\
    top\x12\x17\n\x07stop_id\x18\x02\x20\x01(\tR\x06stopId*\x06\x08\xe8\x07\
    \x10\xd0\x0f*\x06\x08\xa8F\x10\x90NB\x1d\n\x1bcom.google.transit.realtim\
    e\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(28);
            messages.push(FeedMessage::generated_message_descriptor_data());
            messages.push(FeedHeader::generated_message_descriptor_data());
            messages.push(FeedEntity::generated_message_descriptor_data());
            messages.push(TripUpdate::generated_message_descriptor_data());
            messages.push(VehiclePosition::generated_message_descriptor_data());
            messages.push(Alert::generated_message_descriptor_data());
            messages.push(TimeRange::generated_message_descriptor_data());
            messages.push(Position::generated_message_descriptor_data());
            messages.push(TripDescriptor::generated_message_descriptor_data());
            messages.push(VehicleDescriptor::generated_message_descriptor_data());
            messages.push(EntitySelector::generated_message_descriptor_data());
            messages.push(TranslatedString::generated_message_descriptor_data());
            messages.push(TranslatedImage::generated_message_descriptor_data());
            messages.push(Shape::generated_message_descriptor_data());
            messages.push(Stop::generated_message_descriptor_data());
            messages.push(TripModifications::generated_message_descriptor_data());
            messages.push(StopSelector::generated_message_descriptor_data());
            messages.push(ReplacementStop::generated_message_descriptor_data());
            messages.push(trip_update::StopTimeEvent::generated_message_descriptor_data());
            messages.push(trip_update::StopTimeUpdate::generated_message_descriptor_data());
            messages.push(trip_update::TripProperties::generated_message_descriptor_data());
            messages.push(trip_update::stop_time_update::StopTimeProperties::generated_message_descriptor_data());
            messages.push(vehicle_position::CarriageDetails::generated_message_descriptor_data());
            messages.push(trip_descriptor::ModifiedTripSelector::generated_message_descriptor_data());
            messages.push(translated_string::Translation::generated_message_descriptor_data());
            messages.push(translated_image::LocalizedImage::generated_message_descriptor_data());
            messages.push(trip_modifications::Modification::generated_message_descriptor_data());
            messages.push(trip_modifications::SelectedTrips::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(11);
            enums.push(feed_header::Incrementality::generated_enum_descriptor_data());
            enums.push(trip_update::stop_time_update::ScheduleRelationship::generated_enum_descriptor_data());
            enums.push(vehicle_position::VehicleStopStatus::generated_enum_descriptor_data());
            enums.push(vehicle_position::CongestionLevel::generated_enum_descriptor_data());
            enums.push(vehicle_position::OccupancyStatus::generated_enum_descriptor_data());
            enums.push(alert::Cause::generated_enum_descriptor_data());
            enums.push(alert::Effect::generated_enum_descriptor_data());
            enums.push(alert::SeverityLevel::generated_enum_descriptor_data());
            enums.push(trip_descriptor::ScheduleRelationship::generated_enum_descriptor_data());
            enums.push(vehicle_descriptor::WheelchairAccessible::generated_enum_descriptor_data());
            enums.push(stop::WheelchairBoarding::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
